<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CGAL 5.1 - Bounding Volumes: Bounding Volumes Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
      }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png"
           onmouseover="return searchBox.OnSearchSelectShow()"
           onmouseout="return searchBox.OnSearchSelectHide()"
           alt=""/>
      <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)"
             onblur="searchBox.OnSearchFieldFocus(false)"
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt=""/></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.1 - Bounding Volumes
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__PkgBoundingVolumesRef.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Bounding Volumes Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>check generated documentation </dd></dl>
<div class="PkgImage"> <div class="image">
<img src="minCircle.png" alt=""/>
</div>
 </div> <div class="PkgSummary"> <div class="PkgAuthors">Kaspar Fischer, Bernd Gärtner, Thomas Herrmann, Michael Hoffmann, and Sven Schönherr</div> <div class="PkgDescription">This package provides algorithms for computing optimal bounding volumes of point sets. In d-dimensional space, the smallest enclosing sphere, ellipsoid (approximate), and annulus can be computed. In 3-dimensional space, the smallest enclosing strip is available as well, and in 2-dimensional space, there are algorithms for a number of additional volumes (rectangles, parallelograms, \( k=2,3,4\) axis-aligned rectangles). The smallest enclosing sphere algorithm can also be applied to a set of d-dimensional spheres.</div> <div class="PkgManuals"></div> </div> <div class="PkgShortInfo"> <b>Introduced in:</b> <span style="font-variant: small-caps;">CGAL</span> 1.1<br  />
 <b>Depends on:</b> thirdpartyEigen <br  />
 <b>BibTeX:</b> <a href="../Manual/how_to_cite_cgal.html#cgal:fghhs-bv-21b">cgal:fghhs-bv-21b</a><br  />
 <b>License:</b> GPL <br  />
 <b>Windows Demo:</b> <a href="https://www.cgal.org/demo/5.1/bounding_volumes_2.zip">2D Bounding Volumes</a><br  />
<b>Common Demo Dlls:</b> <a href="https://www.cgal.org/demo/5.1/CGAL-demoDLLs.zip">dlls</a><br  />
 </div><h2>Assertions</h2>
<p>The optimization code uses infix <code>OPTIMISATION</code> in the assertions, e.g. defining the compiler flag <code>CGAL_OPTIMISATION_NO_PRECONDITIONS</code> switches precondition checking off, cf. Section <a class="elRef" href="../STL_Extension/index.html#secchecks">Checks</a>.</p>
 <h2 class="groupheader">Classified Reference Pages</h2> <h2>Bounding Areas and Volumes</h2>
<ul>
<li><code><a class="el" href="classCGAL_1_1Min__circle__2.html">CGAL::Min_circle_2</a>&lt;Traits&gt;</code></li>
<li><code><a class="el" href="classCGAL_1_1Min__circle__2__traits__2.html">CGAL::Min_circle_2_traits_2</a>&lt;K&gt;</code></li>
<li><code><a class="el" href="classMinCircle2Traits.html" title="This concept defines the requirements for traits classes of CGAL::Min_circle_2&lt;Traits&gt;.">MinCircle2Traits</a></code><br  />
</li>
<li><code><a class="el" href="classCGAL_1_1Min__ellipse__2.html">CGAL::Min_ellipse_2</a>&lt;Traits&gt;</code></li>
<li><code><a class="el" href="classCGAL_1_1Min__ellipse__2__traits__2.html">CGAL::Min_ellipse_2_traits_2</a>&lt;K&gt;</code></li>
<li><code><a class="el" href="classMinEllipse2Traits.html" title="This concept defines the requirements for traits classes of CGAL::Min_ellipse_2&lt;Traits&gt;.">MinEllipse2Traits</a></code><br  />
</li>
<li><code><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d</a>&lt;Traits&gt;</code></li>
<li><code><a class="el" href="classApproximateMinEllipsoid__d__Traits__d.html" title="This concept defines the requirements for traits classes of CGAL::Approximate_min_ellipsoid_d&lt;Traits&gt;...">ApproximateMinEllipsoid_d_Traits_d</a></code><br  />
</li>
<li><code><a class="el" href="group__PkgBoundingVolumesRef.html#gadcf412afbf5ae512fc88d25d286fa3fa">CGAL::min_rectangle_2</a></code></li>
<li><code><a class="el" href="group__PkgBoundingVolumesRef.html#ga15d5706ceec6fc6fcae0b1625b6da2ac">CGAL::min_parallelogram_2</a></code></li>
<li><code><a class="el" href="group__PkgBoundingVolumesRef.html#gafc685ec39e42e18195ca101631c61cd0">CGAL::min_strip_2</a></code></li>
<li><code><a class="el" href="structCGAL_1_1Min__quadrilateral__default__traits__2.html">CGAL::Min_quadrilateral_default_traits_2</a>&lt;K&gt;</code></li>
<li><code><a class="el" href="classMinQuadrilateralTraits__2.html" title="The concept MinQuadrilateralTraits_2 defines types and operations needed to compute minimum enclosing...">MinQuadrilateralTraits_2</a></code><br  />
</li>
<li><code><a class="el" href="group__PkgBoundingVolumesRef.html#ga37fae6bf8313f85322987d3f230eca53">CGAL::rectangular_p_center_2</a></code></li>
<li><code><a class="el" href="classCGAL_1_1Rectangular__p__center__default__traits__2.html">CGAL::Rectangular_p_center_default_traits_2</a>&lt;K&gt;</code></li>
<li><code><a class="el" href="classRectangularPCenterTraits__2.html" title="The concept RectangularPCenterTraits_2 defines types and operations needed to compute rectilinear -ce...">RectangularPCenterTraits_2</a></code><br  />
</li>
<li><code><a class="el" href="classCGAL_1_1Min__sphere__d.html">CGAL::Min_sphere_d</a>&lt;Traits&gt;</code></li>
<li><code><a class="el" href="classCGAL_1_1Min__annulus__d.html">CGAL::Min_annulus_d</a>&lt;Traits&gt;</code></li>
<li><code><a class="el" href="classCGAL_1_1Min__sphere__annulus__d__traits__2.html">CGAL::Min_sphere_annulus_d_traits_2</a>&lt;K,ET,NT&gt;</code></li>
<li><code><a class="el" href="classCGAL_1_1Min__sphere__annulus__d__traits__3.html">CGAL::Min_sphere_annulus_d_traits_3</a>&lt;K,ET,NT&gt;</code></li>
<li><code><a class="el" href="classCGAL_1_1Min__sphere__annulus__d__traits__d.html">CGAL::Min_sphere_annulus_d_traits_d</a>&lt;K,ET,NT&gt;</code></li>
<li><code><a class="el" href="classMinSphereAnnulusDTraits.html" title="This concept defines the requirements for traits classes of -dimensional min sphere and min annulus a...">MinSphereAnnulusDTraits</a></code><br  />
</li>
<li><code><a class="el" href="classCGAL_1_1Min__sphere__of__spheres__d.html">CGAL::Min_sphere_of_spheres_d</a>&lt;Traits&gt;</code></li>
<li><code><a class="el" href="classMinSphereOfSpheresTraits.html" title="A model of concept MinSphereOfSpheresTraits must provide the following constants, types,...">MinSphereOfSpheresTraits</a></code> </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__PkgBoundingVolumesConcepts"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PkgBoundingVolumesConcepts.html">Concepts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Approximate__min__ellipsoid__d.html">CGAL::Approximate_min_ellipsoid_d&lt; Traits &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCGAL_1_1Approximate__min__ellipsoid__d__traits__2.html">CGAL::Approximate_min_ellipsoid_d_traits_2&lt; K, ET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCGAL_1_1Approximate__min__ellipsoid__d__traits__3.html">CGAL::Approximate_min_ellipsoid_d_traits_3&lt; K, ET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCGAL_1_1Approximate__min__ellipsoid__d__traits__d.html">CGAL::Approximate_min_ellipsoid_d_traits_d&lt; K, ET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__annulus__d.html">CGAL::Min_annulus_d&lt; Traits &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__circle__2.html">CGAL::Min_circle_2&lt; Traits &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__circle__2__traits__2.html">CGAL::Min_circle_2_traits_2&lt; K &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__ellipse__2.html">CGAL::Min_ellipse_2&lt; Traits &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__ellipse__2__traits__2.html">CGAL::Min_ellipse_2_traits_2&lt; K &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCGAL_1_1Min__quadrilateral__default__traits__2.html">CGAL::Min_quadrilateral_default_traits_2&lt; K &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__sphere__annulus__d__traits__2.html">CGAL::Min_sphere_annulus_d_traits_2&lt; K, ET, NT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__sphere__annulus__d__traits__3.html">CGAL::Min_sphere_annulus_d_traits_3&lt; K, ET, NT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__sphere__annulus__d__traits__d.html">CGAL::Min_sphere_annulus_d_traits_d&lt; K, ET, NT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__sphere__d.html">CGAL::Min_sphere_d&lt; Traits &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__sphere__of__points__d__traits__2.html">CGAL::Min_sphere_of_points_d_traits_2&lt; K, FT, UseSqrt, Algorithm &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__sphere__of__points__d__traits__3.html">CGAL::Min_sphere_of_points_d_traits_3&lt; K, FT, UseSqrt, Algorithm &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__sphere__of__points__d__traits__d.html">CGAL::Min_sphere_of_points_d_traits_d&lt; K, FT, Dim, UseSqrt, Algorithm &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__sphere__of__spheres__d.html">CGAL::Min_sphere_of_spheres_d&lt; Traits &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__sphere__of__spheres__d__traits__2.html">CGAL::Min_sphere_of_spheres_d_traits_2&lt; K, FT, UseSqrt, Algorithm &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__sphere__of__spheres__d__traits__3.html">CGAL::Min_sphere_of_spheres_d_traits_3&lt; K, FT, UseSqrt, Algorithm &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__sphere__of__spheres__d__traits__d.html">CGAL::Min_sphere_of_spheres_d_traits_d&lt; K, FT, Dim, UseSqrt, Algorithm &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Rectangular__p__center__default__traits__2.html">CGAL::Rectangular_p_center_default_traits_2&lt; K &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga15d5706ceec6fc6fcae0b1625b6da2ac"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator , class Traits &gt; </td></tr>
<tr class="memitem:ga15d5706ceec6fc6fcae0b1625b6da2ac"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgBoundingVolumesRef.html#ga15d5706ceec6fc6fcae0b1625b6da2ac">CGAL::min_parallelogram_2</a> (ForwardIterator points_begin, ForwardIterator points_end, OutputIterator o, Traits &amp;t=Default_traits)</td></tr>
<tr class="separator:ga15d5706ceec6fc6fcae0b1625b6da2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcf412afbf5ae512fc88d25d286fa3fa"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator , class Traits &gt; </td></tr>
<tr class="memitem:gadcf412afbf5ae512fc88d25d286fa3fa"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgBoundingVolumesRef.html#gadcf412afbf5ae512fc88d25d286fa3fa">CGAL::min_rectangle_2</a> (ForwardIterator points_begin, ForwardIterator points_end, OutputIterator o, Traits &amp;t=Default_traits)</td></tr>
<tr class="separator:gadcf412afbf5ae512fc88d25d286fa3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc685ec39e42e18195ca101631c61cd0"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator , class Traits &gt; </td></tr>
<tr class="memitem:gafc685ec39e42e18195ca101631c61cd0"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgBoundingVolumesRef.html#gafc685ec39e42e18195ca101631c61cd0">CGAL::min_strip_2</a> (ForwardIterator points_begin, ForwardIterator points_end, OutputIterator o, Traits &amp;t=Default_traits)</td></tr>
<tr class="separator:gafc685ec39e42e18195ca101631c61cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fae6bf8313f85322987d3f230eca53"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator , class FT , class Traits &gt; </td></tr>
<tr class="memitem:ga37fae6bf8313f85322987d3f230eca53"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgBoundingVolumesRef.html#ga37fae6bf8313f85322987d3f230eca53">CGAL::rectangular_p_center_2</a> (ForwardIterator f, ForwardIterator l, OutputIterator o, FT &amp;r, int p, const Traits &amp;t=Default_traits)</td></tr>
<tr class="separator:ga37fae6bf8313f85322987d3f230eca53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga15d5706ceec6fc6fcae0b1625b6da2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15d5706ceec6fc6fcae0b1625b6da2ac">&#9670;&nbsp;</a></span>min_parallelogram_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator , class Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator CGAL::min_parallelogram_2 </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>points_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>points_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Traits &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code>Default_traits</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/min_quadrilateral_2.h&gt;</code></p>
<p>The function computes a minimum area enclosing parallelogram \( A(P)\) of a given convex point set \( P\). Note that \( R(P)\) is not necessarily axis-parallel, and it is in general not unique. The focus on convex sets is no restriction, since any parallelogram enclosing \( P\) - as a convex set - contains the convex hull of \( P\). For general point sets one has to compute the convex hull as a preprocessing step.</p>
<p>computes a minimum area enclosing parallelogram of the point set described by [<code>points_begin</code>, <code>points_end</code>), writes its vertices (counterclockwise) to <code>o</code> and returns the past-the-end iterator of this sequence. If the input range is empty, <code>o</code> remains unchanged.</p>
<p>If the input range consists of one element only, this point is written to <code>o</code> four times.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The points denoted by the range [<code>points_begin</code>, <code>points_end</code>) form the boundary of a simple convex polygon \( P\) in counterclockwise orientation.</dd></dl>
<p>The geometric types and operations to be used for the computation are specified by the traits class parameter <code>t</code>. The parameter can be omitted, if <code>ForwardIterator</code> refers to a two-dimensional point type from one the <span style="font-variant: small-caps;">CGAL</span> kernels. In this case, a default traits class (<code><a class="el" href="structCGAL_1_1Min__quadrilateral__default__traits__2.html">Min_quadrilateral_default_traits_2</a>&lt;K&gt;</code>) is used.</p>
<ol>
<li>
If <code>Traits</code> is specified, it must be a model for <code><a class="el" href="classMinQuadrilateralTraits__2.html" title="The concept MinQuadrilateralTraits_2 defines types and operations needed to compute minimum enclosing...">MinQuadrilateralTraits_2</a></code> and the value type <code>VT</code> of <code>ForwardIterator</code> is <code>Traits::Point_2</code>. Otherwise <code>VT</code> must be <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Point__2.html">CGAL::Point_2</a>&lt;K&gt;</code> for some kernel <code>K</code>. </li>
<li>
<code>OutputIterator</code> must accept <code>VT</code> as value type. </li>
</ol>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PkgBoundingVolumesRef.html#gadcf412afbf5ae512fc88d25d286fa3fa">CGAL::min_rectangle_2()</a></code> </dd>
<dd>
<code><a class="el" href="group__PkgBoundingVolumesRef.html#gafc685ec39e42e18195ca101631c61cd0">CGAL::min_strip_2()</a></code> </dd>
<dd>
<code><a class="el" href="classMinQuadrilateralTraits__2.html" title="The concept MinQuadrilateralTraits_2 defines types and operations needed to compute minimum enclosing...">MinQuadrilateralTraits_2</a></code> </dd>
<dd>
<code><a class="el" href="structCGAL_1_1Min__quadrilateral__default__traits__2.html">CGAL::Min_quadrilateral_default_traits_2</a>&lt;K&gt;</code></dd></dl>
<p><b>Implementation</b><br  />
</p>
<p>We use a rotating caliper algorithm <a class="el" href="citelist.html#CITEREF_stvwe-mepa-95">[13]</a>, <a class="el" href="citelist.html#CITEREF_v-fmep-90">[17]</a> with worst case running time linear in the number of input points.</p>
<p><b>Example</b><br  />
</p>
<p>The following code generates a random convex polygon <code>P</code> with 20 vertices and computes the minimum enclosing parallelogram of <code>P</code>.</p>
<p><br  />
<b>File</b> <a class="el" href="Min_quadrilateral_2_2minimum_enclosing_parallelogram_2_8cpp-example.html">Min_quadrilateral_2/minimum_enclosing_parallelogram_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/random_convex_set_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/min_quadrilateral_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                   <a class="codeRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                           Point_2;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classKernel_1_1Line__2.html">Kernel::Line_2</a>                            Line_2;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Polygon_2&lt;Kernel&gt;                   Polygon_2;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Random_points_in_square_2&lt;Point_2&gt;  Generator;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// build a random convex 20-gon p</span></div>
<div class="line">  Polygon_2 p;</div>
<div class="line">  CGAL::random_convex_set_2(20, std::back_inserter(p), Generator(1.0));</div>
<div class="line">  std::cout &lt;&lt; p &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// compute the minimal enclosing parallelogram p_m of p</span></div>
<div class="line">  Polygon_2 p_m;</div>
<div class="line">  <a class="code" href="group__PkgBoundingVolumesRef.html#ga15d5706ceec6fc6fcae0b1625b6da2ac">CGAL::min_parallelogram_2</a>(</div>
<div class="line">    p.vertices_begin(), p.vertices_end(), std::back_inserter(p_m));</div>
<div class="line">  std::cout &lt;&lt; p_m &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Min_quadrilateral_2_2minimum_enclosing_parallelogram_2_8cpp-example.html#a3">Min_quadrilateral_2/minimum_enclosing_parallelogram_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gadcf412afbf5ae512fc88d25d286fa3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcf412afbf5ae512fc88d25d286fa3fa">&#9670;&nbsp;</a></span>min_rectangle_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator , class Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator CGAL::min_rectangle_2 </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>points_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>points_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Traits &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code>Default_traits</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/min_quadrilateral_2.h&gt;</code></p>
<p>The function computes a minimum area enclosing rectangle \( R(P)\) of a given convex point set \( P\). Note that \( R(P)\) is not necessarily axis-parallel, and it is in general not unique. The focus on convex sets is no restriction, since any rectangle enclosing \( P\) - as a convex set - contains the convex hull of \( P\). For general point sets one has to compute the convex hull as a preprocessing step.</p>
<p>computes a minimum area enclosing rectangle of the point set described by [<code>points_begin</code>, <code>points_end</code>), writes its vertices (counterclockwise) to <code>o</code>, and returns the past-the-end iterator of this sequence.</p>
<p>If the input range is empty, <code>o</code> remains unchanged.</p>
<p>If the input range consists of one element only, this point is written to <code>o</code> four times.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The points denoted by the range [<code>points_begin</code>, <code>points_end</code>) form the boundary of a simple convex polygon \( P\) in counterclockwise orientation.</dd></dl>
<p>The geometric types and operations to be used for the computation are specified by the traits class parameter <code>t</code>. The parameter can be omitted, if <code>ForwardIterator</code> refers to a two-dimensional point type from one the <span style="font-variant: small-caps;">CGAL</span> kernels. In this case, a default traits class (<code><a class="el" href="structCGAL_1_1Min__quadrilateral__default__traits__2.html">Min_quadrilateral_default_traits_2</a>&lt;K&gt;</code>) is used.</p>
<ol>
<li>
If <code>Traits</code> is specified, it must be a model for <code><a class="el" href="classMinQuadrilateralTraits__2.html" title="The concept MinQuadrilateralTraits_2 defines types and operations needed to compute minimum enclosing...">MinQuadrilateralTraits_2</a></code> and the value type <code>VT</code> of <code>ForwardIterator</code> is <code>Traits::Point_2</code>. Otherwise <code>VT</code> must be <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Point__2.html">CGAL::Point_2</a>&lt;K&gt;</code> for some kernel <code>K</code>. </li>
<li>
<code>OutputIterator</code> must accept <code>VT</code> as value type. </li>
</ol>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PkgBoundingVolumesRef.html#ga15d5706ceec6fc6fcae0b1625b6da2ac">CGAL::min_parallelogram_2()</a></code> </dd>
<dd>
<code><a class="el" href="group__PkgBoundingVolumesRef.html#gafc685ec39e42e18195ca101631c61cd0">CGAL::min_strip_2()</a></code> </dd>
<dd>
<code><a class="el" href="classMinQuadrilateralTraits__2.html" title="The concept MinQuadrilateralTraits_2 defines types and operations needed to compute minimum enclosing...">MinQuadrilateralTraits_2</a></code> </dd>
<dd>
<code><a class="el" href="structCGAL_1_1Min__quadrilateral__default__traits__2.html">CGAL::Min_quadrilateral_default_traits_2</a>&lt;K&gt;</code></dd></dl>
<p><b>Implementation</b><br  />
</p>
<p>We use a rotating caliper algorithm <a class="el" href="citelist.html#CITEREF_t-sgprc-83">[15]</a> with worst case running time linear in the number of input points.</p>
<p><b>Example</b><br  />
</p>
<p>The following code generates a random convex polygon <code>P</code> with 20 vertices and computes the minimum enclosing rectangle of <code>P</code>.</p>
<p><br  />
<b>File</b> <a class="el" href="Min_quadrilateral_2_2minimum_enclosing_rectangle_2_8cpp-example.html">Min_quadrilateral_2/minimum_enclosing_rectangle_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/random_convex_set_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/min_quadrilateral_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>            <a class="codeRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                           Point_2;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classKernel_1_1Line__2.html">Kernel::Line_2</a>                            Line_2;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Polygon_2&lt;Kernel&gt;                   Polygon_2;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Random_points_in_square_2&lt;Point_2&gt;  Generator;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// build a random convex 20-gon p</span></div>
<div class="line">  Polygon_2 p;</div>
<div class="line">  CGAL::random_convex_set_2(20, std::back_inserter(p), Generator(1.0));</div>
<div class="line">  std::cout &lt;&lt; p &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// compute the minimal enclosing rectangle p_m of p</span></div>
<div class="line">  Polygon_2 p_m;</div>
<div class="line">  <a class="code" href="group__PkgBoundingVolumesRef.html#gadcf412afbf5ae512fc88d25d286fa3fa">CGAL::min_rectangle_2</a>(</div>
<div class="line">    p.vertices_begin(), p.vertices_end(), std::back_inserter(p_m));</div>
<div class="line">  std::cout &lt;&lt; p_m &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Min_quadrilateral_2_2minimum_enclosing_rectangle_2_8cpp-example.html#a3">Min_quadrilateral_2/minimum_enclosing_rectangle_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gafc685ec39e42e18195ca101631c61cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc685ec39e42e18195ca101631c61cd0">&#9670;&nbsp;</a></span>min_strip_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator , class Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator CGAL::min_strip_2 </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>points_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>points_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Traits &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code>Default_traits</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/min_quadrilateral_2.h&gt;</code></p>
<p>The function computes a minimum width enclosing strip \( S(P)\) of a given convex point set \( P\). A strip is the closed region bounded by two parallel lines in the plane. Note that \( S(P)\) is not unique in general. The focus on convex sets is no restriction, since any parallelogram enclosing \( P\) - as a convex set - contains the convex hull of \( P\). For general point sets one has to compute the convex hull as a preprocessing step.</p>
<p>computes a minimum enclosing strip of the point set described by [<code>points_begin</code>, <code>points_end</code>), writes its two bounding lines to <code>o</code> and returns the past-the-end iterator of this sequence.</p>
<p>If the input range is empty or consists of one element only, <code>o</code> remains unchanged.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The points denoted by the range [<code>points_begin</code>, <code>points_end</code>) form the boundary of a simple convex polygon \( P\) in counterclockwise orientation.</dd></dl>
<p>The geometric types and operations to be used for the computation are specified by the traits class parameter <code>t</code>. The parameter can be omitted, if <code>ForwardIterator</code> refers to a two-dimensional point type from one the <span style="font-variant: small-caps;">CGAL</span> kernels. In this case, a default traits class (<code><a class="el" href="structCGAL_1_1Min__quadrilateral__default__traits__2.html">Min_quadrilateral_default_traits_2</a>&lt;K&gt;</code>) is used.</p>
<ol>
<li>
If <code>Traits</code> is specified, it must be a model for <code><a class="el" href="classMinQuadrilateralTraits__2.html" title="The concept MinQuadrilateralTraits_2 defines types and operations needed to compute minimum enclosing...">MinQuadrilateralTraits_2</a></code> and the value type <code>VT</code> of <code>ForwardIterator</code> is <code>Traits::Point_2</code>. Otherwise <code>VT</code> must be <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Point__2.html">CGAL::Point_2</a>&lt;K&gt;</code> for some kernel <code>K</code>. </li>
<li>
<code>OutputIterator</code> must accept <code>Traits::Line_2</code> as value type. </li>
</ol>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PkgBoundingVolumesRef.html#gadcf412afbf5ae512fc88d25d286fa3fa">CGAL::min_rectangle_2()</a></code> </dd>
<dd>
<code><a class="el" href="group__PkgBoundingVolumesRef.html#ga15d5706ceec6fc6fcae0b1625b6da2ac">CGAL::min_parallelogram_2()</a></code> </dd>
<dd>
<code><a class="el" href="classMinQuadrilateralTraits__2.html" title="The concept MinQuadrilateralTraits_2 defines types and operations needed to compute minimum enclosing...">MinQuadrilateralTraits_2</a></code> </dd>
<dd>
<code><a class="el" href="structCGAL_1_1Min__quadrilateral__default__traits__2.html">CGAL::Min_quadrilateral_default_traits_2</a>&lt;K&gt;</code></dd></dl>
<p><b>Implementation</b><br  />
</p>
<p>We use a rotating caliper algorithm <a class="el" href="citelist.html#CITEREF_t-sgprc-83">[15]</a> with worst case running time linear in the number of input points.</p>
<p><b>Example</b><br  />
</p>
<p>The following code generates a random convex polygon <code>P</code> with 20 vertices and computes the minimum enclosing strip of <code>P</code>.</p>
<p><br  />
<b>File</b> <a class="el" href="Min_quadrilateral_2_2minimum_enclosing_strip_2_8cpp-example.html">Min_quadrilateral_2/minimum_enclosing_strip_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/random_convex_set_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/min_quadrilateral_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>            <a class="codeRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                           Point_2;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classKernel_1_1Line__2.html">Kernel::Line_2</a>                            Line_2;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Polygon_2&lt;Kernel&gt;                   Polygon_2;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Random_points_in_square_2&lt;Point_2&gt;  Generator;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// build a random convex 20-gon p</span></div>
<div class="line">  Polygon_2 p;</div>
<div class="line">  CGAL::random_convex_set_2(20, std::back_inserter(p), Generator(1.0));</div>
<div class="line">  std::cout &lt;&lt; p &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// compute the minimal enclosing strip p_m of p</span></div>
<div class="line">  Line_2 p_m[2];</div>
<div class="line">  <a class="code" href="group__PkgBoundingVolumesRef.html#gafc685ec39e42e18195ca101631c61cd0">CGAL::min_strip_2</a>(p.vertices_begin(), p.vertices_end(), p_m);</div>
<div class="line">  std::cout &lt;&lt; p_m[0] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; p_m[1] &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Min_quadrilateral_2_2minimum_enclosing_strip_2_8cpp-example.html#a3">Min_quadrilateral_2/minimum_enclosing_strip_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga37fae6bf8313f85322987d3f230eca53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37fae6bf8313f85322987d3f230eca53">&#9670;&nbsp;</a></span>rectangular_p_center_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator , class FT , class Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator CGAL::rectangular_p_center_2 </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FT &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Traits &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code>Default_traits</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/rectangular_p_center_2.h&gt;</code></p>
<p>Computes rectilinear \( p\)-centers of a planar point set, i.e. a set of \( p\) points such that the maximum minimal \( L_{\infty}\)-distance between both sets is minimized.</p>
<p>More formally the problem can be defined as follows.</p>
<p>Given a finite set \( \mathcal{P}\) of points, compute a point set \( \mathcal{C}\) with \( |\mathcal{C}| \le p\) such that the \( p\)-radius of \( \mathcal{P}\), </p><p class="formulaDsp">
\[ rad_p(\mathcal{P}) := \max_{P \in \mathcal{P}} \min_{Q \in \mathcal{C}} || P - Q ||_\infty \]
</p>
<p> is minimized. We can interpret \( \mathcal{C}\) as the best approximation (with respect to the given metric) for \( \mathcal{P}\) with at most \( p\) points.</p>
<p>computes rectilinear <code>p</code>-centers for the point set described by the range [<code>f</code>, <code>l</code>), sets <code>r</code> to the corresponding \( p\)-radius, writes the at most <code>p</code> center points to <code>o</code> and returns the past-the-end iterator of this sequence.</p>
<dl class="section pre"><dt>Precondition</dt><dd>2 \( \le\) <code>p</code> \( \le\) 4.</dd></dl>
<p>The geometric types and operations to be used for the computation are specified by the traits class parameter <code>t</code>. This parameter can be omitted if <code>ForwardIterator</code> refers to a point type from the 2D-Kernel. In this case, a default traits class (<code><a class="el" href="classCGAL_1_1Rectangular__p__center__default__traits__2.html">Rectangular_p_center_default_traits_2</a>&lt;K&gt;</code>) is used.</p>
<ol>
<li>
<em>Either: (if no traits parameter is given)</em> Value type of <code>ForwardIterator</code> must be <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Point__2.html">CGAL::Point_2</a>&lt;K&gt;</code> for some representation class <code>K</code> and <code>FT</code> must be equivalent to <code>K::FT</code>, </li>
<li>
<em>Or: (if a traits parameter is specified)</em> <code>Traits</code> must be a model for <code><a class="el" href="classRectangularPCenterTraits__2.html" title="The concept RectangularPCenterTraits_2 defines types and operations needed to compute rectilinear -ce...">RectangularPCenterTraits_2</a></code>. </li>
<li>
<code>OutputIterator</code> must accept the value type of <code>ForwardIterator</code> as value type. </li>
</ol>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classRectangularPCenterTraits__2.html" title="The concept RectangularPCenterTraits_2 defines types and operations needed to compute rectilinear -ce...">RectangularPCenterTraits_2</a></code> </dd>
<dd>
<code><a class="el" href="classCGAL_1_1Rectangular__p__center__default__traits__2.html">CGAL::Rectangular_p_center_default_traits_2</a>&lt;K&gt;</code> </dd>
<dd>
<code>CGAL::sorted_matrix_search()</code></dd></dl>
<p><b>Implementation</b><br  />
</p>
<p>The runtime is linear for \( p \in \{2,\,3\}\) and \( \mathcal{O}(n \cdot \log n)\) for \( p = 4\) where \( n\) is the number of input points. These runtimes are worst case optimal. The \( 3\)-center algorithm uses a prune-and-search technique described in <a class="el" href="citelist.html#CITEREF_cgal:h-slacr-99">[9]</a>. The \( 4\)-center implementation uses sorted matrix search <a class="el" href="citelist.html#CITEREF_fj-fkppc-83">[1]</a>, <a class="el" href="citelist.html#CITEREF_fj-gsrsm-84">[2]</a> and fast algorithms for piercing rectangles <a class="el" href="citelist.html#CITEREF_sw-rpppp-96">[14]</a>.</p>
<p><b>Example</b><br  />
</p>
<p>The following code generates a random set of ten points and computes its two-centers.</p>
<p><br  />
<b>File</b> <a class="el" href="Rectangular_p_center_2_2rectangular_p_center_2_8cpp-example.html">Rectangular_p_center_2/rectangular_p_center_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/rectangular_p_center_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Ostream_iterator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/algorithm.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">double</span>                                      FT;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;FT&gt;</a>                  <a class="codeRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                             Point;</div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt;                          Cont;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Random_points_in_square_2&lt;Point&gt;      Generator;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Stream_support/classCGAL_1_1Ostream__iterator.html">CGAL::Ostream_iterator&lt;Point,std::ostream&gt;</a>  OIterator;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> n = 10;</div>
<div class="line">  <span class="keywordtype">int</span> p = 2;</div>
<div class="line">  OIterator cout_ip(std::cout);</div>
<div class="line">  <a class="codeRef" href="../Stream_support/group__PkgStreamSupportRef.html#ga2f2176255429973ea7bf156804a53857">CGAL::set_pretty_mode</a>(std::cout);</div>
<div class="line"> </div>
<div class="line">  Cont points;</div>
<div class="line">  <a class="codeRef" href="../STL_Extension/group__STLAlgos.html#gacb8df77d1d07b9cfff3fdd2f5d9c4fda">std::copy_n</a>(Generator(1), n, std::back_inserter(points));</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Generated Point Set:\n&quot;</span>;</div>
<div class="line">  std::copy(points.begin(), points.end(), cout_ip);</div>
<div class="line"> </div>
<div class="line">  FT p_radius;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span> &lt;&lt; p &lt;&lt; <span class="stringliteral">&quot;-centers:\n&quot;</span>;</div>
<div class="line">  <a class="code" href="group__PkgBoundingVolumesRef.html#ga37fae6bf8313f85322987d3f230eca53">CGAL::rectangular_p_center_2</a>(</div>
<div class="line">    points.begin(), points.end(), cout_ip, p_radius, 3);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span> &lt;&lt; p &lt;&lt; <span class="stringliteral">&quot;-radius = &quot;</span> &lt;&lt; p_radius &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Rectangular_p_center_2_2rectangular_p_center_2_8cpp-example.html#a5">Rectangular_p_center_2/rectangular_p_center_2.cpp</a>.</dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassCGAL_1_1Ostream__iterator_html"><div class="ttname"><a href="../Stream_support/classCGAL_1_1Ostream__iterator.html">CGAL::Ostream_iterator</a></div></div>
<div class="ttc" id="agroup__PkgBoundingVolumesRef_html_ga15d5706ceec6fc6fcae0b1625b6da2ac"><div class="ttname"><a href="group__PkgBoundingVolumesRef.html#ga15d5706ceec6fc6fcae0b1625b6da2ac">CGAL::min_parallelogram_2</a></div><div class="ttdeci">OutputIterator min_parallelogram_2(ForwardIterator points_begin, ForwardIterator points_end, OutputIterator o, Traits &amp;t=Default_traits)</div></div>
<div class="ttc" id="aclassKernel_1_1Point__2_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a></div></div>
<div class="ttc" id="agroup__STLAlgos_html_gacb8df77d1d07b9cfff3fdd2f5d9c4fda"><div class="ttname"><a href="../STL_Extension/group__STLAlgos.html#gacb8df77d1d07b9cfff3fdd2f5d9c4fda">copy_n</a></div><div class="ttdeci">OutputIterator copy_n(InputIterator first, Size n, OutputIterator result)</div></div>
<div class="ttc" id="agroup__PkgBoundingVolumesRef_html_gadcf412afbf5ae512fc88d25d286fa3fa"><div class="ttname"><a href="group__PkgBoundingVolumesRef.html#gadcf412afbf5ae512fc88d25d286fa3fa">CGAL::min_rectangle_2</a></div><div class="ttdeci">OutputIterator min_rectangle_2(ForwardIterator points_begin, ForwardIterator points_end, OutputIterator o, Traits &amp;t=Default_traits)</div></div>
<div class="ttc" id="anamespaceKernel_html"><div class="ttname"><a href="../Kernel_23/namespaceKernel.html">Kernel</a></div></div>
<div class="ttc" id="agroup__PkgBoundingVolumesRef_html_ga37fae6bf8313f85322987d3f230eca53"><div class="ttname"><a href="group__PkgBoundingVolumesRef.html#ga37fae6bf8313f85322987d3f230eca53">CGAL::rectangular_p_center_2</a></div><div class="ttdeci">OutputIterator rectangular_p_center_2(ForwardIterator f, ForwardIterator l, OutputIterator o, FT &amp;r, int p, const Traits &amp;t=Default_traits)</div></div>
<div class="ttc" id="agroup__PkgStreamSupportRef_html_ga2f2176255429973ea7bf156804a53857"><div class="ttname"><a href="../Stream_support/group__PkgStreamSupportRef.html#ga2f2176255429973ea7bf156804a53857">set_pretty_mode</a></div><div class="ttdeci">IO::Mode set_pretty_mode(std::ios &amp;s)</div></div>
<div class="ttc" id="aclassKernel_1_1Line__2_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Line__2.html">Kernel::Line_2</a></div></div>
<div class="ttc" id="agroup__PkgBoundingVolumesRef_html_gafc685ec39e42e18195ca101631c61cd0"><div class="ttname"><a href="group__PkgBoundingVolumesRef.html#gafc685ec39e42e18195ca101631c61cd0">CGAL::min_strip_2</a></div><div class="ttdeci">OutputIterator min_strip_2(ForwardIterator points_begin, ForwardIterator points_end, OutputIterator o, Traits &amp;t=Default_traits)</div></div>
<div class="ttc" id="astructCGAL_1_1Simple__cartesian_html"><div class="ttname"><a href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian</a></div></div>
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</div>
</body>
</html>
