<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CGAL 5.1 - 3D Generalized Barycentric Coordinates: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
      }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png"
           onmouseover="return searchBox.OnSearchSelectShow()"
           onmouseout="return searchBox.OnSearchSelectHide()"
           alt=""/>
      <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)"
             onblur="searchBox.OnSearchFieldFocus(false)"
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt=""/></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.1 - 3D Generalized Barycentric Coordinates
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_3D_Generalized_Barycentric_Coordinates"></a></p> <div id="autotoc" class="toc"></div> <dl class="section author"><dt>Authors</dt><dd>Antonio Gomes, Dmitry Anisimov</dd></dl>
<h1><a class="anchor" id="gbc_3_introduction"></a>
Introduction</h1>
<p>Barycentric coordinates are an important tool in computer graphics and geometric modeling. Originally, these coordinates were used to represent a given point with respect to a simplex but have been later generalized to more complex shapes.</p>
<p>The package 3D Generalized Barycentric Coordinates offers an efficient and robust implementation of three-dimensional closed-form, generalized barycentric coordinates defined for convex simplicial polytopes.</p>
<p>In particular, this package includes an implementation of Wachspress, discrete harmonic, mean value, and one extra function to calculate barycentric coordinates with respect to tetrahedra. In this implementation, we restrict our polyhedra to convex ones with triangular faces, although some of the coordinates may accept more general shapes.</p>
<h1><a class="anchor" id="gbc_3_interface"></a>
Software Design</h1>
<p>Wachspress, discrete harmonic, and mean value coordinates are all generalized barycentric coordinates that can be computed analytically. All of the three analytic coordinates can be computed either by instantiating a class or through a free function. Tetrahedron coordinates can be computed only through the free function.</p>
<p>Similarly to <code>Barycentric_coordinates::Computation_policy_2</code> in the 2D package, we can specify a computation policy <a class="el" href="namespaceCGAL_1_1Barycentric__coordinates.html#a3b1fcc9819b571ab581d36c8a2def381" title="Computation_policy_3 provides a way to choose an asymptotic time complexity of the algorithm and its ...">Barycentric_coordinates::Computation_policy_3</a> that can be FAST or FAST_WITH_EDGE_CASES for each of the three analytical coordinates. The difference between them is that FAST_WITH_EDGE_CASES treats points near the boundaries by projecting them into the face of the polyhedron and then calculating triangle coordinates. Note that, different from the 2D package, there is not yet an implementation for a PRECISE algorithm.</p>
<p>The output of a query point is the coordinate value with respect to each vertex, the number of coordinates values being the same as the number of vertices, and the ordering is also the same.</p>
<p>All class and function templates are parameterized by a traits class, which is a model of the concept <a class="el" href="classCGAL_1_1Barycentric__coordinates_1_1BarycentricTraits__3.html" title="A concept that describes the set of requirements of the template parameter GeomTraits used to paramet...">BarycentricTraits_3</a>. It provides all necessary geometric primitives, predicates, and constructions, which are required for the computation. All models of <a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a> can be used. A polyhedron is provided as a model of the concept <a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a> with a property map that maps a vertex from the polyhedron to <a class="el" href="classCGAL_1_1Barycentric__coordinates_1_1BarycentricTraits__3.html#a5ea4b9075f236033b886ef9a048b5320" title="A model of Kernel::Point_3.">BarycentricTraits_3::Point_3</a>.</p>
<h1><a class="anchor" id="gbc_3_examples"></a>
Examples</h1>
<p>To facilitate the process of learning this package, we provide various examples with basic usage of different barycentric components.</p>
<h2><a class="anchor" id="tetra_example"></a>
Tetrahedron Coordinates</h2>
<p>In this example, we use the global function <code><a class="el" href="group__PkgBarycentricCoordinates3RefFunctions.html#ga2e16fb5ede2f871133d22e301b0b6769" title="computes tetrahedron coordinates.">tetrahedron_coordinates_in_array()</a></code>. We compute coordinates for the tetrahedron whose vertices are the points in the set {(0,0,0), (1,0,0), (0,1,0), (0,0,1)}. We use points inside, outside and at the boundary of the tetrahedron. <a class="anchor" id="tetra_coord_example"></a><br  />
<b>File</b> <a class="el" href="Barycentric_coordinates_3_2tetrahedron_coordinates_8cpp-example.html">Barycentric_coordinates_3/tetrahedron_coordinates.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_3/tetrahedron_coordinates.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//Typedefs</span></div>
<div class="line"><span class="keyword">using</span> <a class="codeRef" href="../Kernel_23/namespaceKernel.html">Kernel</a> = <a class="codeRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> FT = <a class="codeRef" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div>
<div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct tetrahedron</span></div>
<div class="line">  <span class="keyword">const</span> Point_3 p0(0.0, 0.0, 0.0);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p1(1.0, 0.0, 0.0);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p2(0.0, 1.0, 0.0);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p3(0.0, 0.0, 1.0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Instantiate some interior, boundary, and exterior query points for which we compute coordinates.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point_3&gt; queries = {</div>
<div class="line">    Point_3(0.25f , 0.25f, 0.25f), Point_3(0.3f, 0.2f, 0.3f),         <span class="comment">// interior query points</span></div>
<div class="line">    Point_3(0.1f, 0.1f, 0.1f), Point_3(0.2f, 0.5f, 0.3f),             <span class="comment">// interior query points</span></div>
<div class="line">    Point_3(0.0f , 0.0f, 0.5f), Point_3(0.4f, 0.4f, 0.0f),            <span class="comment">// boundary query points</span></div>
<div class="line">    Point_3(0.0f, 0.4f, 0.4f), Point_3(0.4f, 0.0f, 0.4f),             <span class="comment">// boundary query points</span></div>
<div class="line">    Point_3(0.5f, 0.5f, 0.5f), Point_3(2.0f, 0.0f, 0.0f),             <span class="comment">// exterior query points</span></div>
<div class="line">    Point_3(-1.0f, -1.0f, 1.0f), Point_3(0.5f, 0.5f, -2.0f)};         <span class="comment">// exterior query point</span></div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;tetrahedra coordinates (all queries): &quot;</span> &lt;&lt; std::endl</div>
<div class="line">    &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get an array of triangle coordinates for all query points</span></div>
<div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; queries.size(); i++){</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> coords_array =</div>
<div class="line">    <a class="code" href="group__PkgBarycentricCoordinates3RefFunctions.html#ga2e16fb5ede2f871133d22e301b0b6769">CGAL::Barycentric_coordinates::tetrahedron_coordinates_in_array</a>(p0, p1, p2, p3, queries[i]);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;tetrahedra coordinates (query &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt;</div>
<div class="line">      coords_array[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; coords_array[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt;</div>
<div class="line">      coords_array[2] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; coords_array[3] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="wp_3_example"></a>
Wachspress Coordinates</h2>
<p>In this example, we generate 250 random points inside a unit sphere, centered at the origin, then we take the convex hull of this set of points and use this as our polyhedron. Finally, we calculate Wachspress coordinates for all of these 250 points. <a class="anchor" id="wp_3_coord_example"></a><br  />
<b>File</b> <a class="el" href="Barycentric_coordinates_3_2wachspress_coordinates_8cpp-example.html">Barycentric_coordinates_3/wachspress_coordinates.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/convex_hull_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_faces.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_3/Wachspress_coordinates_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> <a class="codeRef" href="../Kernel_23/namespaceKernel.html">Kernel</a> =  <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div>
<div class="line"><span class="keyword">using</span> FT = <a class="codeRef" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div>
<div class="line"><span class="keyword">using</span> Point_3 =  <a class="codeRef" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div>
<div class="line"><span class="keyword">using</span> Surface_mesh = CGAL::Surface_mesh&lt;Point_3&gt;;</div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"><span class="keyword">using</span> CP3 = <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html#a3b1fcc9819b571ab581d36c8a2def381">CGAL::Barycentric_coordinates::Computation_policy_3</a>;</div>
<div class="line"><span class="keyword">using</span> WP = <a class="code" href="classCGAL_1_1Barycentric__coordinates_1_1Wachspress__coordinates__3.html">CGAL::Barycentric_coordinates::Wachspress_coordinates_3&lt;Surface_mesh, Kernel&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">  <a class="codeRef" href="../Generator/classCGAL_1_1Random__points__in__sphere__3.html">CGAL::Random_points_in_sphere_3&lt;Point_3&gt;</a> gen(1.0);</div>
<div class="line">  std::vector&lt;Point_3&gt; points;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::size_t number_of_points = 250;</div>
<div class="line">  <a class="codeRef" href="../STL_Extension/group__STLAlgos.html#gacb8df77d1d07b9cfff3fdd2f5d9c4fda">std::copy_n</a>(gen, number_of_points, std::back_inserter(points));</div>
<div class="line"> </div>
<div class="line">  Surface_mesh sm;</div>
<div class="line">  CGAL::convex_hull_3(points.begin(), points.end(), sm);</div>
<div class="line">  <span class="keyword">const</span> std::size_t number_of_vertices = num_vertices(sm);</div>
<div class="line"> </div>
<div class="line">  WP wp(sm, CP3::FAST_WITH_EDGE_CASES);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Computed Wachspress coordinates: &quot;</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; number_of_points; i++){</div>
<div class="line"> </div>
<div class="line">      std::vector&lt;FT&gt; coordinates;</div>
<div class="line">      coordinates.reserve(number_of_vertices);</div>
<div class="line">      wp(points[i], std::back_inserter(coordinates));</div>
<div class="line"> </div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Point &quot;</span> &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">for</span>(std::size_t j = 0; j &lt; number_of_vertices; j++)</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Coordinate &quot;</span> &lt;&lt; j + 1 &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; coordinates[j] &lt;&lt; <span class="stringliteral">&quot;; &quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      std::cout &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="dh_3_example"></a>
Discrete Harmonic Coordinates</h2>
<p>This example is very similar to the one used with tetrahedron coordinates. We start with a regular icosahedron and for points inside, outside and at the boundary, we calculate discrete harmonic coordinates. In this example, we use the fast with edge cases algorithm because it treats points very close to the boundaries. <a class="anchor" id="dh_3_coord_example"></a><br  />
<b>File</b> <a class="el" href="Barycentric_coordinates_3_2discrete_harmonic_coordinates_8cpp-example.html">Barycentric_coordinates_3/discrete_harmonic_coordinates.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#define PHI 1.6180339887498948482</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_faces.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_3/Discrete_harmonic_coordinates_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> <a class="codeRef" href="../Kernel_23/namespaceKernel.html">Kernel</a> =  <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div>
<div class="line"><span class="keyword">using</span> FT = <a class="codeRef" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div>
<div class="line"><span class="keyword">using</span> Point_3 =  <a class="codeRef" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div>
<div class="line"><span class="keyword">using</span> Surface_mesh = CGAL::Surface_mesh&lt;Point_3&gt;;</div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"><span class="keyword">using</span> CP3 = <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html#a3b1fcc9819b571ab581d36c8a2def381">CGAL::Barycentric_coordinates::Computation_policy_3</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line"> </div>
<div class="line">  Surface_mesh icosahedron;</div>
<div class="line">  <a class="codeRef" href="../BGL/group__PkgBGLHelperFct.html#gac35ac7a3cb0ca4a5452548a304f3835e">CGAL::make_icosahedron</a>(icosahedron, Point_3(0.0, 0.0, 0.0), 2.0);</div>
<div class="line">  PMP::triangulate_faces(faces(icosahedron), icosahedron);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;FT&gt; coords;</div>
<div class="line">  std::vector&lt;Point_3&gt; queries{</div>
<div class="line">    Point_3(-1, 1 + PHI, PHI), Point_3(0.5, (1+3*PHI)/2, PHI/2), Point_3(1, 1+PHI, -PHI), <span class="comment">//Boundary</span></div>
<div class="line">    Point_3(-1, 1, 1), Point_3(0, 0, 1), Point_3(0, 2, 1),                                <span class="comment">//Interior</span></div>
<div class="line">    Point_3(0, 2*PHI, 4), Point_3(0, 3, 2*PHI), Point_3(4, 0, 0)};                        <span class="comment">//EXterior</span></div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Discrete harmonic coordinates : &quot;</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; query : queries){</div>
<div class="line"> </div>
<div class="line">    coords.clear();</div>
<div class="line">    <a class="code" href="group__PkgBarycentricCoordinates3RefFunctions.html#gad6c592dd7d79544e692ab3091635fd67">CGAL::Barycentric_coordinates::discrete_harmonic_coordinates_3</a>(</div>
<div class="line">      icosahedron, query, std::back_inserter(coords), CP3::FAST_WITH_EDGE_CASES);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Output discrete harmonics coordinates.</span></div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; coords.size() -1; ++i) {</div>
<div class="line">      std::cout &lt;&lt; coords[i] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; coords[coords.size() -1] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="mv_3_example"></a>
Mean Value Coordinates</h2>
<p>This example shows how to compute mean value coordinates for a set of points in a star-shaped polyhedron. We note that this type of coordinate is well-defined for a concave polyhedron but it may yield negative coordinate values for points outside the polyhedron's kernel (shown in blue).</p>
<p><a class="anchor" id="mv_3_coord_example"></a><a class="anchor" id="fig__mv_3_example"></a></p><div class="image">
<img src="mv_coords_example_3.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__mv_3_example">fig__mv_3_example</a> Example's point pattern. </p> </div> <p> <br  />
</p>
<p><br  />
<b>File</b> <a class="el" href="Barycentric_coordinates_3_2mean_value_coordinates_8cpp-example.html">Barycentric_coordinates_3/mean_value_coordinates.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_faces.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_3/Mean_value_coordinates_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> <a class="codeRef" href="../Kernel_23/namespaceKernel.html">Kernel</a> =  <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div>
<div class="line"><span class="keyword">using</span> FT = <a class="codeRef" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div>
<div class="line"><span class="keyword">using</span> Point_3 =  <a class="codeRef" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div>
<div class="line"><span class="keyword">using</span> Surface_mesh = CGAL::Surface_mesh&lt;Point_3&gt;;</div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"><span class="keyword">using</span> CP3 = <a class="code" href="namespaceCGAL_1_1Barycentric__coordinates.html#a3b1fcc9819b571ab581d36c8a2def381">CGAL::Barycentric_coordinates::Computation_policy_3</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line"> </div>
<div class="line">  Surface_mesh concave;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> Point_3 p0(0, 3, 0);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p1(1, 1, 0);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p2(3, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p3(0, 0, 0);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p4(0, 0, 3);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p5(0, 3, 3);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p6(1, 1, 3);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p7(3, 0, 3);</div>
<div class="line"> </div>
<div class="line">  <a class="codeRef" href="../BGL/group__PkgBGLHelperFct.html#gad9df350e98780f0c213046d8a257358e">CGAL::make_hexahedron</a>(p0, p1, p2, p3, p4, p5, p6, p7, concave);</div>
<div class="line">  PMP::triangulate_faces(faces(concave), concave);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;FT&gt; coords;</div>
<div class="line">  std::vector&lt;Point_3&gt; queries{</div>
<div class="line">    Point_3(FT(1)/FT(2), FT(1)/FT(2), FT(1)), Point_3(FT(1)/FT(3), FT(1)/FT(3), FT(2)), <span class="comment">// Only points in the kernel</span></div>
<div class="line">    Point_3(FT(4)/FT(3), FT(1)/FT(3), FT(1)), Point_3(FT(4)/FT(3), FT(1)/FT(3), FT(2)),</div>
<div class="line">    Point_3(FT(1)/FT(3), FT(4)/FT(3), FT(1)), Point_3(FT(1)/FT(3), FT(4)/FT(3), FT(2))};</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Mean value coordinates : &quot;</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; query : queries){</div>
<div class="line"> </div>
<div class="line">    coords.clear();</div>
<div class="line">    <a class="code" href="group__PkgBarycentricCoordinates3RefFunctions.html#ga3ccda69bc3e3bddd1059d588dded2762">CGAL::Barycentric_coordinates::mean_value_coordinates_3</a>(</div>
<div class="line">      concave, query, std::back_inserter(coords), CP3::FAST);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Output mean value coordinates.</span></div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; coords.size() -1; ++i) {</div>
<div class="line">      std::cout &lt;&lt; coords[i] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; coords[coords.size() -1] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="shape_deform_example_3"></a>
Shape deformation</h2>
<p>This is an example that shows how to deform a simple smooth sphere into another shape, topologically equivalent. To achieve this, we enclose the sphere inside a cube cage, then we calculate the barycentric coordinate of each vertex with respect to the cube cage. After deforming the cage, we calculate the linear combination of the points to get the deformed sphere vertices.</p>
<p><a class="anchor" id="shape_deform_example"></a><a class="anchor" id="fig__shape_deform_example_3"></a></p><div class="image">
<img src="shape_deform_example_3.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__shape_deform_example_3">fig__shape_deform_example_3</a> The shape on the left is deformed into the shape on the right. </p> </div> <p> <br  />
</p>
<p><br  />
<b>File</b> <a class="el" href="Barycentric_coordinates_3_2shape_deformation_8cpp-example.html">Barycentric_coordinates_3/shape_deformation.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_default_triangulation_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Complex_2_in_triangulation_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/make_surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Implicit_surface_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/IO/facets_in_complex_2_to_triangle_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_faces.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_3/Mean_value_coordinates_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> <a class="codeRef" href="../Kernel_23/namespaceKernel.html">Kernel</a> = <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// default triangulation for Surface_mesher</span></div>
<div class="line"><span class="keyword">using</span> Tr =  CGAL::Surface_mesh_default_triangulation_3;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> C2t3 = CGAL::Complex_2_in_triangulation_3&lt;Tr&gt;;</div>
<div class="line"><span class="keyword">using</span> Sphere_3 = <a class="codeRef" href="../Kernel_23/classKernel.html#a601207c3e7157f868a2e473791bf38c5">Kernel::Sphere_3</a>;</div>
<div class="line"><span class="keyword">using</span> Point_3 =  <a class="codeRef" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div>
<div class="line"><span class="keyword">using</span> FT =  <a class="codeRef" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> FT (*Function)(Point_3);</div>
<div class="line"><span class="keyword">using</span>  Surface_3 = CGAL::Implicit_surface_3&lt;Kernel, Function&gt;;</div>
<div class="line"><span class="keyword">using</span> Surface_mesh =  CGAL::Surface_mesh&lt;Point_3&gt;;</div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line">FT sphere_function (Point_3 p){</div>
<div class="line">  <span class="keyword">const</span> FT x2=p.x()*p.x(), y2=p.y()*p.y(), z2=p.z()*p.z();</div>
<div class="line">  <span class="keywordflow">return</span> x2+y2+z2-1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">  Tr tr;</div>
<div class="line">  C2t3 c2t3(tr);</div>
<div class="line"> </div>
<div class="line">  Surface_3 surface(sphere_function, Sphere_3(<a class="codeRef" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>, 2.));</div>
<div class="line">  CGAL::Surface_mesh_default_criteria_3&lt;Tr&gt; criteria(30., 0.1, 0.1);</div>
<div class="line">  CGAL::make_surface_mesh(c2t3, surface, criteria, CGAL::Non_manifold_tag());</div>
<div class="line"> </div>
<div class="line">  Surface_mesh sm;</div>
<div class="line">  Surface_mesh deformed;</div>
<div class="line">  CGAL::facets_in_complex_2_to_triangle_mesh(c2t3, sm);</div>
<div class="line">  deformed = sm;</div>
<div class="line"> </div>
<div class="line">  Surface_mesh quad_cage;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> Point_3 p0(2, -2, -2), p0_new(5, -5, -5);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p1(2, 2, -2), p1_new(3, 3, -3);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p2(-2, 2, -2), p2_new(-2, 2, -2);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p3(-2, -2, -2), p3_new(-3, -3, -3);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> Point_3 p4(-2, -2, 2), p4_new(-3, -3, 3);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p5(2, -2, 2), p5_new(4, -4, 4);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p6(2, 2, 2), p6_new(2, 2, 3);</div>
<div class="line">  <span class="keyword">const</span> Point_3 p7(-2, 2, 2), p7_new(-3, 3, 3);</div>
<div class="line"> </div>
<div class="line">  <a class="codeRef" href="../BGL/group__PkgBGLHelperFct.html#gad9df350e98780f0c213046d8a257358e">CGAL::make_hexahedron</a>(p0, p1, p2, p3, p4, p5, p6, p7, quad_cage);</div>
<div class="line">  PMP::triangulate_faces(faces(quad_cage), quad_cage);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classCGAL_1_1Barycentric__coordinates_1_1Mean__value__coordinates__3.html">CGAL::Barycentric_coordinates::Mean_value_coordinates_3&lt;Surface_mesh, Kernel&gt;</a> mv(quad_cage);</div>
<div class="line">  <span class="keyword">auto</span> vertex_to_point_map = get_property_map(CGAL::vertex_point, deformed);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;FT&gt; coords;</div>
<div class="line">  std::vector&lt;Point_3&gt; target_cube{p0_new, p1_new, p2_new, p3_new,</div>
<div class="line">                                   p4_new, p5_new, p6_new, p7_new};</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; v : vertices(deformed)){</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> Point_3 vertex_val = get(vertex_to_point_map, v);</div>
<div class="line">    coords.clear();</div>
<div class="line">    mv(vertex_val, std::back_inserter(coords));</div>
<div class="line"> </div>
<div class="line">    FT x = FT(0), y = FT(0), z = FT(0);</div>
<div class="line">    <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; 8; i++){</div>
<div class="line"> </div>
<div class="line">      x += target_cube[i].x() * coords[i];</div>
<div class="line">      y += target_cube[i].y() * coords[i];</div>
<div class="line">      z += target_cube[i].z() * coords[i];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    put(vertex_to_point_map, v, Point_3(x, y, z));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::ofstream out_original(<span class="stringliteral">&quot;sphere.off&quot;</span>);</div>
<div class="line">  out_original &lt;&lt; sm &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::ofstream out_deformed(<span class="stringliteral">&quot;deformed_sphere.off&quot;</span>);</div>
<div class="line">  out_deformed &lt;&lt; deformed &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="gbc_3_degeneracies"></a>
Edge Cases</h1>
<p>The precision of each coordinate depends on the used <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code>. If an inexact kernel is used and the user is not sure if the points are near the boundaries, <code>FAST_WITH_EDGE_CASES</code> algorithm should be used. Implementation details are described in <a class="el" href="citelist.html#CITEREF_cgal:bc:f-wmvc-14">[1]</a> for Wachspress and mean value coordinates, and in <a class="el" href="citelist.html#CITEREF_cgal:bc:jlw-ggcccsp-07">[3]</a> for discrete harmonic coordinates.</p>
<p>For each coordinate, it is necessary to make divisions by the signed distance between the query point and each face. So, if one of these distances is zero or close to zero (query point at the boundary), it will cause a division by zero error or numerical instability, respectively. To avoid this, the main purpose of the FAST_WITH_EDGE_CASES algorithm is to extend the region where the analytical coordinates are well-defined. It adds the guarantee to calculate points near the boundaries. The way it works is very simple: before calculating any coordinate, the algorithm checks, for each face, if the distance between the query point and the plane is less than one predetermined tolerance. If so, instead of calculating the analytical form of the coordinates, it decomposes the query point with respect to this particular face and then calculates triangle coordinates. However, for Wachspress coordinates, the 2D version is used because the faces are not necessarily triangular. Note that for every vertex that does not belong to this face, the coordinate value will be zero.</p>
<h2><a class="anchor" id="gbc_3_degeneracies_tetrahedron"></a>
Tetrahedron Coordinates</h2>
<p>To compute tetrahedron coordinates of the query point <code>q</code>, we adopt the simple formula: </p><center> \(w_i = \frac{V_i}{V}\) </center><p>where \(V_i\) is the signed volume of the sub-tetrahedron opposite to the vertex \(i\) and \(V\) is the total volume of the tetrahedron, that is \(V = V_0 + V_1 + V_2 + V_3\).</p>
<p>These coordinates can be computed exactly if an exact number type is chosen, for any query point in the space and with respect to any non-degenerate tetrahedron. No special cases are handled. The computation always yields the correct result. The notion of correctness depends on the precision of the used number type. Note that for exterior points some coordinate values will be negative.</p>
<h2><a class="anchor" id="gbc_3_degeneracies_wachspress"></a>
Wachspress Coordinates</h2>
<p>For each vertex \(v\), let \(f_1, f_2, ..., f_k\) be the \(k\) faces incident to \(v\). We are assuming that the faces are taken in counterclockwise order.</p>
<p>We can define \({p_f}({q}) = \frac{{n_f}}{h_f({q})}\), and \(h_f({q}) = ({v} - {q})\cdot {n_f}\) as the perpendicular distance of \(q\) to \(f\). For the face \(f\), let \({n_f}\) denote its unit outward normal.</p>
<p>So, to compute Wachspress coordinates of the query point <code>q</code>, we adopt the simple formula: </p><center> \(w_v({q}) = \sum_{i=2}^{k-1}det({p_{f_1}}({q}), {p_{f_i}}({q}), {p_{f_{i+1}}}({q}))\) </center><p>In this implementation, Wachspress coordinates are well defined in the closure of any convex polyhedra. If an exact number type is chosen, they are computed exactly.</p>
<h2><a class="anchor" id="gbc_3_degeneracies_discrete_harmonic"></a>
Discrete Harmonic Coordinates</h2>
<p>To compute discrete harmonic coordinates of the query point <code>q</code>, we adopt the simple formula: </p><center> \(w_i = \sum_{T : v_i \in T} \frac{cot[\theta_i^T]h_i^T}{2}\) </center><p>where, within a triangle face T = {v1, v2, v3}, \(\theta_i^T\) is the dihedral angle between T and triangle {x, \(v_{i+1}\), \(v_{i−1}\)}, and \(h_i^T\) is the edge length \(|v_{i+1} − v_{i−1}|\).</p>
<p>Discrete harmonic coordinates cannot be computed exactly due to a square root operation. Although, if an exact number type is used, the default precision of the computation depends only on two CGAL functions: CGAL::to_double() and CGAL::sqrt(). In this implementation, discrete harmonic coordinates are well defined in the closure of any convex polyhedra with triangular faces. Unlike Wachspress coordinates, they are not necessarily positive.</p>
<h2><a class="anchor" id="gbc_3_degeneracies_mean_value"></a>
Mean Value Coordinates</h2>
<p>To compute mean value coordinates of the query point <code>q</code>, we adopt the simple formula: </p><center> \(w_i = \frac{1}{2}\sum_{j=1}^3 \beta_j\frac{{m_j}\cdot {m_{i+1}}}{{e_i}\cdot {m_{i+1}}}\) </center><p>where a vertex v is projected to the point (unit vector) \(e_v = \frac{({v} - {q})}{|{v - q}|}\), and \({m_i} = \frac{{e_i} \times {e_{i+1}}}{|{e_i} \times {e_{i+1}}|}\). \(\beta_j \in (0, \pi)\) is the angle between \(e_i\) and \(e_{i+1}\).</p>
<p>Like discrete harmonic, mean value coordinates cannot be computed exactly due to a square root operation. In this implementation, mean value coordinates are well defined everywhere in the space, but just for polyhedra with triangular faces. Also, they are non-negative in the kernel of a star-shaped polyhedron.</p>
<h1><a class="anchor" id="gbc_3_performance"></a>
Performance</h1>
<p>Efficiency is really important in this implementation. These coordinates are used in applications that require calculations for millions of points, thus developing metrics to evaluate performance is absolutely necessary. In this section, we present benchmark results for each algorithm.</p>
<p>To make the benchmark and evaluate runtimes, for each analytic coordinate, we regularly sample approximately \(n^3\) ( \(n\) varying from 1 to 100) strictly interior points with respect to a cube with unit length, and then calculate its coordinate values (see figure below). The results are represented in a log-log scale plot and are the mean value of 10 loop iterations (see plot below).</p>
<p><a class="anchor" id="fig__bc_coords_bench_structure_3"></a></p><div class="image">
<img src="bc_coords_bench_structure_3.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__bc_coords_bench_structure_3">fig__bc_coords_bench_structure_3</a> The points shown in red are the sample points used to make the benchmark. </p> </div> <p> <br  />
</p>
<p>The performance strongly depends on the chosen kernel, for this test, we choose to use <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">Simple_cartesian</a>&lt;double&gt;</code> because is much faster than others. Also, we can see that time (WP) &lt;&lt; time (DH) &lt; time (MV). This happens because wp implementation has fewer instructions per loop than the other two, so naturally, the computation time tends to be faster.</p>
<p><a class="anchor" id="fig__bc_coords_bench_3"></a></p><div class="image">
<img src="bc_coords_bench_3.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__bc_coords_bench_3">fig__bc_coords_bench_3</a> Time in seconds to compute \(n^3\) coordinate values for a cube. Are represented in the graph: Wachspress (blue), discrete harmonic (orange), and mean value (green). </p> </div> <p> <br  />
</p>
<p>Tetrahedron coordinates are not shown in the same plot because the test is slightly different. For this one, we simply show in the table below the results for some pre-defined quantity of points. The test is done by regularly sampling strictly interior points with respect to a tetrahedron with unit sides that lies on the coordinate axis.</p>
<table class="markdownTable" align="center">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Number of points  </th><th class="markdownTableHeadCenter">Total time (in seconds)  </th></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">1000 </td><td class="markdownTableBodyCenter">0.002662682533  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">50000 </td><td class="markdownTableBodyCenter">0.09459688663  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">100000 </td><td class="markdownTableBodyCenter">0.1865084648  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">500000 </td><td class="markdownTableBodyCenter">0.8238497972  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">1000000 </td><td class="markdownTableBodyCenter">1.665773582  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">5000000 </td><td class="markdownTableBodyCenter">8.359417105  </td></tr>
</table>
<p>To benchmark each coordinate, we used a 2.6 GHz Intel Core i7 processor (6 cores) and 16 GB DDR4 2933MHz memory. The installed operating system was Ubuntu 20.04 LTS.</p>
<h1><a class="anchor" id="gbc_3_history"></a>
History</h1>
<p>This package was introduced during GSoC 2021 and implemented by Antonio Gomes under the supervision of Dmitry Anisimov.</p>
<h1><a class="anchor" id="gbc_3_acknowledgments"></a>
Acknowledgments</h1>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__inexact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Random__points__in__sphere__3_html"><div class="ttname"><a href="../Generator/classCGAL_1_1Random__points__in__sphere__3.html">CGAL::Random_points_in_sphere_3</a></div></div>
<div class="ttc" id="agroup__PkgBarycentricCoordinates3RefFunctions_html_ga3ccda69bc3e3bddd1059d588dded2762"><div class="ttname"><a href="group__PkgBarycentricCoordinates3RefFunctions.html#ga3ccda69bc3e3bddd1059d588dded2762">CGAL::Barycentric_coordinates::mean_value_coordinates_3</a></div><div class="ttdeci">OutIterator mean_value_coordinates_3(const TriangleMesh &amp;triangle_mesh, const Point_3 &amp;query, OutIterator c_begin, const Computation_policy_3 policy=Computation_policy_3::FAST_WITH_EDGE_CASES)</div><div class="ttdoc">computes 3D mean value coordinates.</div><div class="ttdef"><b>Definition:</b> Mean_value_coordinates_3.h:409</div></div>
<div class="ttc" id="anamespaceCGAL_1_1Barycentric__coordinates_html_a3b1fcc9819b571ab581d36c8a2def381"><div class="ttname"><a href="namespaceCGAL_1_1Barycentric__coordinates.html#a3b1fcc9819b571ab581d36c8a2def381">CGAL::Barycentric_coordinates::Computation_policy_3</a></div><div class="ttdeci">Computation_policy_3</div><div class="ttdoc">Computation_policy_3 provides a way to choose an asymptotic time complexity of the algorithm and its ...</div><div class="ttdef"><b>Definition:</b> barycentric_enum_3.h:36</div></div>
<div class="ttc" id="agroup__STLAlgos_html_gacb8df77d1d07b9cfff3fdd2f5d9c4fda"><div class="ttname"><a href="../STL_Extension/group__STLAlgos.html#gacb8df77d1d07b9cfff3fdd2f5d9c4fda">copy_n</a></div><div class="ttdeci">OutputIterator copy_n(InputIterator first, Size n, OutputIterator result)</div></div>
<div class="ttc" id="aclassCGAL_1_1Barycentric__coordinates_1_1Mean__value__coordinates__3_html"><div class="ttname"><a href="classCGAL_1_1Barycentric__coordinates_1_1Mean__value__coordinates__3.html">CGAL::Barycentric_coordinates::Mean_value_coordinates_3</a></div><div class="ttdoc">3D mean value coordinates.</div><div class="ttdef"><b>Definition:</b> Mean_value_coordinates_3.h:54</div></div>
<div class="ttc" id="aclassKernel_html_a601207c3e7157f868a2e473791bf38c5"><div class="ttname"><a href="../Kernel_23/classKernel.html#a601207c3e7157f868a2e473791bf38c5">Kernel::Sphere_3</a></div><div class="ttdeci">unspecified_type Sphere_3</div></div>
<div class="ttc" id="aclassKernel_html_ae82b7f4be77dd5b8819ebe419e4ae753"><div class="ttname"><a href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a></div><div class="ttdeci">unspecified_type Point_3</div></div>
<div class="ttc" id="agroup__PkgBarycentricCoordinates3RefFunctions_html_gad6c592dd7d79544e692ab3091635fd67"><div class="ttname"><a href="group__PkgBarycentricCoordinates3RefFunctions.html#gad6c592dd7d79544e692ab3091635fd67">CGAL::Barycentric_coordinates::discrete_harmonic_coordinates_3</a></div><div class="ttdeci">OutIterator discrete_harmonic_coordinates_3(const TriangleMesh &amp;triangle_mesh, const Point_3 &amp;query, OutIterator c_begin, const Computation_policy_3 policy=Computation_policy_3::FAST)</div><div class="ttdoc">computes 3D discrete harmonic coordinates.</div><div class="ttdef"><b>Definition:</b> Discrete_harmonic_coordinates_3.h:400</div></div>
<div class="ttc" id="agroup__kernel__enums_html_ga9d272a8e3a8080b851741b6d3a44afdc"><div class="ttname"><a href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">ORIGIN</a></div><div class="ttdeci">const CGAL::Origin ORIGIN</div></div>
<div class="ttc" id="anamespaceKernel_html"><div class="ttname"><a href="../Kernel_23/namespaceKernel.html">Kernel</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Barycentric__coordinates_1_1Wachspress__coordinates__3_html"><div class="ttname"><a href="classCGAL_1_1Barycentric__coordinates_1_1Wachspress__coordinates__3.html">CGAL::Barycentric_coordinates::Wachspress_coordinates_3</a></div><div class="ttdoc">3D Wachspress coordinates.</div><div class="ttdef"><b>Definition:</b> Wachspress_coordinates_3.h:55</div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_gac35ac7a3cb0ca4a5452548a304f3835e"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#gac35ac7a3cb0ca4a5452548a304f3835e">make_icosahedron</a></div><div class="ttdeci">boost::graph_traits&lt; Graph &gt;::halfedge_descriptor make_icosahedron(Graph &amp;g, const P &amp;center=P(0, 0, 0), typename CGAL::Kernel_traits&lt; P &gt;::Kernel::FT radius=1.0)</div></div>
<div class="ttc" id="agroup__PkgBarycentricCoordinates3RefFunctions_html_ga2e16fb5ede2f871133d22e301b0b6769"><div class="ttname"><a href="group__PkgBarycentricCoordinates3RefFunctions.html#ga2e16fb5ede2f871133d22e301b0b6769">CGAL::Barycentric_coordinates::tetrahedron_coordinates_in_array</a></div><div class="ttdeci">std::array&lt; typename GeomTraits::FT, 4 &gt; tetrahedron_coordinates_in_array(const typename GeomTraits::Point_3 &amp;p0, const typename GeomTraits::Point_3 &amp;p1, const typename GeomTraits::Point_3 &amp;p2, const typename GeomTraits::Point_3 &amp;p3, const typename GeomTraits::Point_3 &amp;query, const GeomTraits &amp;traits)</div><div class="ttdoc">computes tetrahedron coordinates.</div><div class="ttdef"><b>Definition:</b> tetrahedron_coordinates.h:145</div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_gad9df350e98780f0c213046d8a257358e"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#gad9df350e98780f0c213046d8a257358e">make_hexahedron</a></div><div class="ttdeci">boost::graph_traits&lt; Graph &gt;::halfedge_descriptor make_hexahedron(const P &amp;p0, const P &amp;p1, const P &amp;p2, const P &amp;p3, const P &amp;p4, const P &amp;p5, const P &amp;p6, const P &amp;p7, Graph &amp;g)</div></div>
<div class="ttc" id="aclassKernel_html_a55e83f5a9f8ca43588b02ae8256a8fbd"><div class="ttname"><a href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a></div><div class="ttdeci">unspecified_type FT</div></div>
<div class="ttc" id="astructCGAL_1_1Simple__cartesian_html"><div class="ttname"><a href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian</a></div></div>
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</div>
</body>
</html>
