<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CGAL 5.1 - 2D Boolean Operations on Nef Polygons: CGAL::Nef_polyhedron_2&lt; T &gt; Class Template Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
      }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png"
           onmouseover="return searchBox.OnSearchSelectShow()"
           onmouseout="return searchBox.OnSearchSelectHide()"
           alt=""/>
      <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)"
             onblur="searchBox.OnSearchFieldFocus(false)"
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt=""/></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.1 - 2D Boolean Operations on Nef Polygons
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classCGAL_1_1Nef__polyhedron__2.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classCGAL_1_1Nef__polyhedron__2-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">CGAL::Nef_polyhedron_2&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__PkgNef2Ref.html">2D Boolean Operations on Nef Polygons Reference</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;CGAL/Nef_polyhedron_2.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class CGAL::Nef_polyhedron_2&lt; T &gt;</h3>

<p>An instance of data type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt;T&gt;</code> is a subset of the plane that is the result of forming complements and intersections starting from a finite set <code>H</code> of halfspaces. <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a></code> is closed under all binary set operations <code>intersection</code>, <code>union</code>, <code>difference</code>, <code>complement</code> and under the topological operations <code>boundary</code>, <code>closure</code>, and <code>interior</code>.</p>
<p>The template parameter <code>T</code> is specified via an extended kernel concept. <code>T</code> must be a model of the concept <code><a class="el" href="classExtendedKernelTraits__2.html" title="ExtendedKernelTraits_2 is a kernel concept providing extended geometryIt is called extended geometry ...">ExtendedKernelTraits_2</a></code>.</p>
<p><b>Exploration - Point location - Ray shooting</b><br  />
</p>
<p>As Nef polyhedra are the result of forming complements and intersections starting from a set <code>H</code> of halfspaces that are defined by oriented lines in the plane, they can be represented by an attributed plane map \( M = (V,E,F)\). For topological queries within <code>M</code> the following types and operations allow exploration access to this structure.</p>
<p><b>Implementation</b><br  />
</p>
<p>Nef polyhedra are implemented on top of a halfedge data structure and use linear space in the number of vertices, edges and facets. Operations like <code>empty</code> take constant time. The operations <code>clear</code>, <code>complement</code>, <code>interior</code>, <code>closure</code>, <code>boundary</code>, <code>regularization</code>, input and output take linear time. All binary set operations and comparison operations take time \( O(n \log n)\) where \( n\) is the size of the output plus the size of the input.</p>
<p>The point location and ray shooting operations are implemented in two flavors. The <code>NAIVE</code> operations run in linear query time without any preprocessing, the <code>DEFAULT</code> operations (equals <code>LMWT</code>) run in sub-linear query time, but preprocessing is triggered with the first operation. Preprocessing takes time \( O(N^2)\), the sub-linear point location time is either logarithmic when LEDA's persistent dictionaries are present or if not then the point location time is worst-case linear, but experiments show often sublinear runtimes. Ray shooting equals point location plus a walk in the constrained triangulation overlayed on the plane map representation. The cost of the walk is proportional to the number of triangles passed in direction <code>d</code> until an obstacle is met. In a minimum weight triangulation of the obstacles (the plane map representing the polyhedron) the theory provides a \( O(\sqrt{n})\) bound for the number of steps. Our locally minimum weight triangulation approximates the minimum weight triangulation only heuristically (the calculation of the minimum weight triangulation is conjectured to be NP hard). Thus we have no runtime guarantee but a strong experimental motivation for its approximation.</p>
<p><b>Example</b><br  />
</p>
<p>Nef polyhedra are parameterized by a so-called extended geometric kernel. There are three kernels, one based on a homogeneous representation of extended points called <code><a class="el" href="classCGAL_1_1Extended__homogeneous.html">Extended_homogeneous</a>&lt;RT&gt;</code> where <code>RT</code> is a ring type providing additionally a <code>gcd</code> operation, one based on a Cartesian representation of extended points called <code><a class="el" href="classCGAL_1_1Extended__cartesian.html">Extended_cartesian</a>&lt;NT&gt;</code> where <code>NT</code> is a field type, and finally <code><a class="el" href="classCGAL_1_1Filtered__extended__homogeneous.html">Filtered_extended_homogeneous</a>&lt;RT&gt;</code> (an optimized version of the first). The following example uses the filtered homogeneous kernel to construct the intersection of two halfspaces.</p>
<p><br  />
<b>File</b> <a class="el" href="Nef_2_2nef_2_intersection_8cpp-example.html">Nef_2/nef_2_intersection.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" href="../Number_types/Exact__integer_8h.html">CGAL/Exact_integer.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Filtered_extended_homogeneous.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Nef_polyhedron_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Number_types/group__nt__cgal.html#gae96d924c796bfc4e781d28f81df43c52">CGAL::Exact_integer</a> RT;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Filtered__extended__homogeneous.html">CGAL::Filtered_extended_homogeneous&lt;RT&gt;</a> Extended_kernel;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2&lt;Extended_kernel&gt;</a> Nef_polyhedron;</div>
<div class="line"><span class="keyword">typedef</span> Nef_polyhedron::Line  <a class="code" href="classCGAL_1_1Nef__polyhedron__2.html#a1e0e9aa5868dc87384c1cb65df4b2828">Line</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Nef_polyhedron N1(<a class="code" href="classCGAL_1_1Nef__polyhedron__2.html#a1e0e9aa5868dc87384c1cb65df4b2828">Line</a>(1,0,0));</div>
<div class="line">  Nef_polyhedron N2(<a class="code" href="classCGAL_1_1Nef__polyhedron__2.html#a1e0e9aa5868dc87384c1cb65df4b2828">Line</a>(0,1,0), Nef_polyhedron::EXCLUDED);</div>
<div class="line">  Nef_polyhedron N3 = N1 * N2; <span class="comment">// line (*)</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>After line (*) <code>N3</code> is the intersection of <code>N1</code> and <code>N2</code>. The member types of <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; <a class="el" href="classCGAL_1_1Extended__homogeneous.html">Extended_homogeneous</a>&lt;NT&gt; &gt;</code> map to corresponding types of the standard <span style="font-variant: small-caps;">CGAL</span> geometry kernel (type equality in pseudo-code notation):</p>
<div class="fragment"><div class="line"><a class="code" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2&lt; CGAL::Extended_cartesian&lt; FT &gt;</a> &gt;<a class="code" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">::Point</a> == <a class="codeRef" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;FT&gt;::Point_2</a></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2&lt; CGAL::Extended_homogeneous&lt; RT &gt;</a> &gt;<a class="code" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">::Point</a> == <a class="codeRef" href="../Kernel_23/structCGAL_1_1Homogeneous.html">CGAL::Homogeneous&lt; RT &gt;::Point_2</a></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2&lt; CGAL::Filtered_extended_homogeneous&lt;RT&gt;</a> &gt;<a class="code" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">::Point</a> == <a class="codeRef" href="../Kernel_23/structCGAL_1_1Homogeneous.html">CGAL::Homogeneous&lt;RT&gt;::Point_2</a></div>
</div><!-- fragment --><p>The same holds for the types <code>Line</code> and <code>Direction</code> in the local scope of <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt;...&gt;</code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Nef_2_2nef_2_construction_8cpp-example.html#_a1">Nef_2/nef_2_construction.cpp</a>, <a class="el" href="Nef_2_2nef_2_exploration_8cpp-example.html#_a1">Nef_2/nef_2_exploration.cpp</a>, <a class="el" href="Nef_2_2nef_2_intersection_8cpp-example.html#_a1">Nef_2/nef_2_intersection.cpp</a>, and <a class="el" href="Nef_2_2nef_2_polylines_8cpp-example.html#_a2">Nef_2/nef_2_polylines.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Explorer.html">Explorer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Topological__explorer.html">Topological_explorer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Types</h2></td></tr>
<tr class="memitem:a8cb9d4db15905d56ae4be1d502aab8ff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ff">Boundary</a> { <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ffa94a77215e20d6be276e5b7ec032c3139">EXCLUDED</a>, 
<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43">INCLUDED</a>
 }</td></tr>
<tr class="memdesc:a8cb9d4db15905d56ae4be1d502aab8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction selection.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ff">More...</a><br /></td></tr>
<tr class="separator:a8cb9d4db15905d56ae4be1d502aab8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f1c19c50d23c0a759c2d2b1bb60bd0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0">Content</a> { <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0a4786fccb661c483062e02b784e1c722c">EMPTY</a>, 
<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0acbd2d7c6e526cfad582f001a6a0042a3">COMPLETE</a>
 }</td></tr>
<tr class="memdesc:ab5f1c19c50d23c0a759c2d2b1bb60bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction selection  <a href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0">More...</a><br /></td></tr>
<tr class="separator:ab5f1c19c50d23c0a759c2d2b1bb60bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cddcb2fffffe488f897da1f3cf4abc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">Location_mode</a> { <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af">DEFAULT</a>, 
<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcaca828eed6da20a9383aeb13ef1dcdbed">NAIVE</a>, 
<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abca775e12588827baac52ff0b8d3dec1616">LMWT</a>
 }</td></tr>
<tr class="memdesc:aa7cddcb2fffffe488f897da1f3cf4abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">selectionflag for the point location mode.  <a href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">More...</a><br /></td></tr>
<tr class="separator:aa7cddcb2fffffe488f897da1f3cf4abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0e9aa5868dc87384c1cb65df4b2828"><td class="memItemLeft" align="right" valign="top">typedef unspecified_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a1e0e9aa5868dc87384c1cb65df4b2828">Line</a></td></tr>
<tr class="memdesc:a1e0e9aa5868dc87384c1cb65df4b2828"><td class="mdescLeft">&#160;</td><td class="mdescRight">the oriented lines modeling halfplanes.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a1e0e9aa5868dc87384c1cb65df4b2828">More...</a><br /></td></tr>
<tr class="separator:a1e0e9aa5868dc87384c1cb65df4b2828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dba79fcf624dbb9e3163f68f4f75e00"><td class="memItemLeft" align="right" valign="top">typedef unspecified_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">Point</a></td></tr>
<tr class="memdesc:a5dba79fcf624dbb9e3163f68f4f75e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">the affine points of the plane.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">More...</a><br /></td></tr>
<tr class="separator:a5dba79fcf624dbb9e3163f68f4f75e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5779dcd0d9aa9007e4bafe0bceb3ae4"><td class="memItemLeft" align="right" valign="top">typedef unspecified_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ac5779dcd0d9aa9007e4bafe0bceb3ae4">Direction</a></td></tr>
<tr class="memdesc:ac5779dcd0d9aa9007e4bafe0bceb3ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">directions in our plane.  <a href="classCGAL_1_1Nef__polyhedron__2.html#ac5779dcd0d9aa9007e4bafe0bceb3ae4">More...</a><br /></td></tr>
<tr class="separator:ac5779dcd0d9aa9007e4bafe0bceb3ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac640be6a8130703344a89ad4859d4867"><td class="memItemLeft" align="right" valign="top">typedef unspecified_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ac640be6a8130703344a89ad4859d4867">Polygons_tag</a></td></tr>
<tr class="memdesc:ac640be6a8130703344a89ad4859d4867"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag for calling polygon constructor.  <a href="classCGAL_1_1Nef__polyhedron__2.html#ac640be6a8130703344a89ad4859d4867">More...</a><br /></td></tr>
<tr class="separator:ac640be6a8130703344a89ad4859d4867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa372c8392eae26070c04575ec8d198d"><td class="memItemLeft" align="right" valign="top">typedef unspecified_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#afa372c8392eae26070c04575ec8d198d">Polylines_tag</a></td></tr>
<tr class="memdesc:afa372c8392eae26070c04575ec8d198d"><td class="mdescLeft">&#160;</td><td class="mdescRight">tag for calling polyline constructor.  <a href="classCGAL_1_1Nef__polyhedron__2.html#afa372c8392eae26070c04575ec8d198d">More...</a><br /></td></tr>
<tr class="separator:afa372c8392eae26070c04575ec8d198d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae6d7ad3ab6fa5417b87d9cfec493af"><td class="memItemLeft" align="right" valign="top">typedef unspecified_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a></td></tr>
<tr class="memdesc:a2ae6d7ad3ab6fa5417b87d9cfec493af"><td class="mdescLeft">&#160;</td><td class="mdescRight">a generic handle to an object of the underlying plane map.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">More...</a><br /></td></tr>
<tr class="separator:a2ae6d7ad3ab6fa5417b87d9cfec493af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Creation</h2></td></tr>
<tr class="memitem:ab4af61958347b01b464fb87ce06d7571"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab4af61958347b01b464fb87ce06d7571">Nef_polyhedron_2</a> (<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0">Content</a> plane=<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0a4786fccb661c483062e02b784e1c722c">EMPTY</a>)</td></tr>
<tr class="memdesc:ab4af61958347b01b464fb87ce06d7571"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates an instance <code>N</code> of type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt;T&gt;</code> and initializes it to the empty set if <code>plane == EMPTY</code> and to the whole plane if <code>plane == COMPLETE</code>.  <a href="classCGAL_1_1Nef__polyhedron__2.html#ab4af61958347b01b464fb87ce06d7571">More...</a><br /></td></tr>
<tr class="separator:ab4af61958347b01b464fb87ce06d7571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6718ebe574d776b5cc9c767eff9acf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5c6718ebe574d776b5cc9c767eff9acf">Nef_polyhedron_2</a> (<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a1e0e9aa5868dc87384c1cb65df4b2828">Line</a> l, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ff">Boundary</a> line=<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43">INCLUDED</a>)</td></tr>
<tr class="memdesc:a5c6718ebe574d776b5cc9c767eff9acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a Nef polyhedron <code>N</code> containing the halfplane left of <code>l</code> including <code>l</code> if <code>line==INCLUDED</code>, excluding <code>l</code> if <code>line==EXCLUDED</code>.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a5c6718ebe574d776b5cc9c767eff9acf">More...</a><br /></td></tr>
<tr class="separator:a5c6718ebe574d776b5cc9c767eff9acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97de249020e516c3e6a599f18a1f745"><td class="memTemplParams" colspan="2">template&lt;class Forward_iterator &gt; </td></tr>
<tr class="memitem:ab97de249020e516c3e6a599f18a1f745"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab97de249020e516c3e6a599f18a1f745">Nef_polyhedron_2</a> (Forward_iterator it, Forward_iterator end, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ff">Boundary</a> b=<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43">INCLUDED</a>)</td></tr>
<tr class="memdesc:ab97de249020e516c3e6a599f18a1f745"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a Nef polyhedron <code>N</code> from the simple polygon <code>P</code> spanned by the list of points in the iterator range <code>[it,end)</code> and including its boundary if <code>b = INCLUDED</code> excluding the boundary otherwise.  <a href="classCGAL_1_1Nef__polyhedron__2.html#ab97de249020e516c3e6a599f18a1f745">More...</a><br /></td></tr>
<tr class="separator:ab97de249020e516c3e6a599f18a1f745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68e86a3bdeddb587363bf73edaae184"><td class="memTemplParams" colspan="2">template&lt;class Forward_iterator &gt; </td></tr>
<tr class="memitem:ad68e86a3bdeddb587363bf73edaae184"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ad68e86a3bdeddb587363bf73edaae184">Nef_polyhedron_2</a> (Forward_iterator it, Forward_iterator end, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ac640be6a8130703344a89ad4859d4867">Polygons_tag</a>)</td></tr>
<tr class="memdesc:ad68e86a3bdeddb587363bf73edaae184"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator range [it, end) defines a set point ranges, each of which defines the boundary of simple polygon.  <a href="classCGAL_1_1Nef__polyhedron__2.html#ad68e86a3bdeddb587363bf73edaae184">More...</a><br /></td></tr>
<tr class="separator:ad68e86a3bdeddb587363bf73edaae184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af756cab6f8712b0aaaeddb72f6115aee"><td class="memTemplParams" colspan="2">template&lt;class Forward_iterator &gt; </td></tr>
<tr class="memitem:af756cab6f8712b0aaaeddb72f6115aee"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#af756cab6f8712b0aaaeddb72f6115aee">Nef_polyhedron_2</a> (Forward_iterator it, Forward_iterator end, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#afa372c8392eae26070c04575ec8d198d">Polylines_tag</a>)</td></tr>
<tr class="memdesc:af756cab6f8712b0aaaeddb72f6115aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator range [it, end) defines a set point ranges, each of which defines a polyline.  <a href="classCGAL_1_1Nef__polyhedron__2.html#af756cab6f8712b0aaaeddb72f6115aee">More...</a><br /></td></tr>
<tr class="separator:af756cab6f8712b0aaaeddb72f6115aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Operations</h2></td></tr>
<tr class="memitem:ad8a2c296b76e8bb29c715bbabac6654b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ad8a2c296b76e8bb29c715bbabac6654b">clear</a> (<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0">Content</a> plane=<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0a4786fccb661c483062e02b784e1c722c">EMPTY</a>)</td></tr>
<tr class="memdesc:ad8a2c296b76e8bb29c715bbabac6654b"><td class="mdescLeft">&#160;</td><td class="mdescRight">makes <code>N</code> the empty set if <code>plane == EMPTY</code> and the full plane if <code>plane == COMPLETE</code>.  <a href="classCGAL_1_1Nef__polyhedron__2.html#ad8a2c296b76e8bb29c715bbabac6654b">More...</a><br /></td></tr>
<tr class="separator:ad8a2c296b76e8bb29c715bbabac6654b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5014cbf16cdb80a88729b259741bf16f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5014cbf16cdb80a88729b259741bf16f">is_empty</a> ()</td></tr>
<tr class="memdesc:a5014cbf16cdb80a88729b259741bf16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if <code>N</code> is empty, false otherwise.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a5014cbf16cdb80a88729b259741bf16f">More...</a><br /></td></tr>
<tr class="separator:a5014cbf16cdb80a88729b259741bf16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3ed3315cae400bdfdfcac4c9be5bce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ada3ed3315cae400bdfdfcac4c9be5bce">is_plane</a> ()</td></tr>
<tr class="memdesc:ada3ed3315cae400bdfdfcac4c9be5bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if <code>N</code> is the whole plane, false otherwise.  <a href="classCGAL_1_1Nef__polyhedron__2.html#ada3ed3315cae400bdfdfcac4c9be5bce">More...</a><br /></td></tr>
<tr class="separator:ada3ed3315cae400bdfdfcac4c9be5bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de0d51fb5bc6e9e73f87047fa0f1f3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8de0d51fb5bc6e9e73f87047fa0f1f3f">contains</a> (<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a> h)</td></tr>
<tr class="memdesc:a8de0d51fb5bc6e9e73f87047fa0f1f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff the object <code>h</code> is contained in the set represented by <code>N</code>.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a8de0d51fb5bc6e9e73f87047fa0f1f3f">More...</a><br /></td></tr>
<tr class="separator:a8de0d51fb5bc6e9e73f87047fa0f1f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40387867733e7ddc47f5a29f33cac02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ae40387867733e7ddc47f5a29f33cac02">contained_in_boundary</a> (<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a> h)</td></tr>
<tr class="memdesc:ae40387867733e7ddc47f5a29f33cac02"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff the object <code>h</code> is contained in the \( 1\)-skeleton of <code>N</code>.  <a href="classCGAL_1_1Nef__polyhedron__2.html#ae40387867733e7ddc47f5a29f33cac02">More...</a><br /></td></tr>
<tr class="separator:ae40387867733e7ddc47f5a29f33cac02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eca334fed696603f7bed85da151582c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a1eca334fed696603f7bed85da151582c">locate</a> (const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">Location_mode</a> m=<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af">DEFAULT</a>)</td></tr>
<tr class="memdesc:a1eca334fed696603f7bed85da151582c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a generic handle <code>h</code> to an object (face, halfedge, vertex) of the underlying plane map that contains the point <code>p</code> in its relative interior.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a1eca334fed696603f7bed85da151582c">More...</a><br /></td></tr>
<tr class="separator:a1eca334fed696603f7bed85da151582c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59903a8983c436a9be57e4bf9d49cfd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a59903a8983c436a9be57e4bf9d49cfd8">ray_shoot</a> (const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">Point</a> &amp;p, const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ac5779dcd0d9aa9007e4bafe0bceb3ae4">Direction</a> &amp;d, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">Location_mode</a> m=<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af">DEFAULT</a>)</td></tr>
<tr class="memdesc:a59903a8983c436a9be57e4bf9d49cfd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a handle <code>h</code> with <code>N.contains(h)</code>, that can be converted to a <code>Vertex_/Halfedge_/Face_const_handle</code> as described above.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a59903a8983c436a9be57e4bf9d49cfd8">More...</a><br /></td></tr>
<tr class="separator:a59903a8983c436a9be57e4bf9d49cfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e858bf751d797d0299e312238bd0688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a7e858bf751d797d0299e312238bd0688">ray_shoot_to_boundary</a> (const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">Point</a> &amp;p, const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ac5779dcd0d9aa9007e4bafe0bceb3ae4">Direction</a> &amp;d, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">Location_mode</a> m=<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af">DEFAULT</a>)</td></tr>
<tr class="memdesc:a7e858bf751d797d0299e312238bd0688"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a handle <code>h</code>, that can be converted to a <code>Vertex_/Halfedge_const_handle</code> as described above.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a7e858bf751d797d0299e312238bd0688">More...</a><br /></td></tr>
<tr class="separator:a7e858bf751d797d0299e312238bd0688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067bf42f1a6b9b13a6fcc45baa30299b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Explorer.html">Explorer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a067bf42f1a6b9b13a6fcc45baa30299b">explorer</a> ()</td></tr>
<tr class="memdesc:a067bf42f1a6b9b13a6fcc45baa30299b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a decorator object that allows read-only access of the underlying plane map.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a067bf42f1a6b9b13a6fcc45baa30299b">More...</a><br /></td></tr>
<tr class="separator:a067bf42f1a6b9b13a6fcc45baa30299b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Constructive Operations</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpa6d8aafaf3479f2f4cbe8c194d5f8602"></a>Additionally there are operators <code>*,+,-,^,!</code> which implement the binary operations <em>intersection</em>, <em>join</em>, <em>difference</em>, <em>symmetric difference</em>, and the unary operation <em>complement</em>, respectively.</p>
<p>There are also the corresponding modification operations There are also comparison operations like <code>&lt;,&lt;=,&gt;,&gt;=,==,!=</code> which implement the relations subset, subset or equal, superset, superset or equal, equality, inequality, respectively. </p>
</td></tr>
<tr class="memitem:a6d563177e49fd01a39e44f1183797a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a6d563177e49fd01a39e44f1183797a96">complement</a> ()</td></tr>
<tr class="memdesc:a6d563177e49fd01a39e44f1183797a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the complement of <code>N</code> in the plane.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a6d563177e49fd01a39e44f1183797a96">More...</a><br /></td></tr>
<tr class="separator:a6d563177e49fd01a39e44f1183797a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b82c78fe42d878d9418023fe02590f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a3b82c78fe42d878d9418023fe02590f9">interior</a> ()</td></tr>
<tr class="memdesc:a3b82c78fe42d878d9418023fe02590f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the interior of <code>N</code>.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a3b82c78fe42d878d9418023fe02590f9">More...</a><br /></td></tr>
<tr class="separator:a3b82c78fe42d878d9418023fe02590f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7250e12e77f1d7e64a773243cb413b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a7250e12e77f1d7e64a773243cb413b8f">closure</a> ()</td></tr>
<tr class="memdesc:a7250e12e77f1d7e64a773243cb413b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the closure of <code>N</code>.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a7250e12e77f1d7e64a773243cb413b8f">More...</a><br /></td></tr>
<tr class="separator:a7250e12e77f1d7e64a773243cb413b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5caead26e295b819211f52c2e616b568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5caead26e295b819211f52c2e616b568">boundary</a> ()</td></tr>
<tr class="memdesc:a5caead26e295b819211f52c2e616b568"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the boundary of <code>N</code>.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a5caead26e295b819211f52c2e616b568">More...</a><br /></td></tr>
<tr class="separator:a5caead26e295b819211f52c2e616b568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0ed6d7b4eb2a47d449c097cdc5cfff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a1d0ed6d7b4eb2a47d449c097cdc5cfff">regularization</a> ()</td></tr>
<tr class="memdesc:a1d0ed6d7b4eb2a47d449c097cdc5cfff"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the regularized polyhedron (closure of interior).  <a href="classCGAL_1_1Nef__polyhedron__2.html#a1d0ed6d7b4eb2a47d449c097cdc5cfff">More...</a><br /></td></tr>
<tr class="separator:a1d0ed6d7b4eb2a47d449c097cdc5cfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab341639df2691491b20e8adf96b94d62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab341639df2691491b20e8adf96b94d62">intersection</a> (const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt; &amp;N1)</td></tr>
<tr class="memdesc:ab341639df2691491b20e8adf96b94d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>N</code> \( \cap\) <code>N1</code>.  <a href="classCGAL_1_1Nef__polyhedron__2.html#ab341639df2691491b20e8adf96b94d62">More...</a><br /></td></tr>
<tr class="separator:ab341639df2691491b20e8adf96b94d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd32f367b34bb3fd67028b61082888b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#acfd32f367b34bb3fd67028b61082888b">join</a> (const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt; &amp;N1)</td></tr>
<tr class="memdesc:acfd32f367b34bb3fd67028b61082888b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>N</code> \( \cup\) <code>N1</code>.  <a href="classCGAL_1_1Nef__polyhedron__2.html#acfd32f367b34bb3fd67028b61082888b">More...</a><br /></td></tr>
<tr class="separator:acfd32f367b34bb3fd67028b61082888b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a312aa40e2b58167279881c1d14d62f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a6a312aa40e2b58167279881c1d14d62f">difference</a> (const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt; &amp;N1)</td></tr>
<tr class="memdesc:a6a312aa40e2b58167279881c1d14d62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>N</code> \( -\) <code>N1</code>.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a6a312aa40e2b58167279881c1d14d62f">More...</a><br /></td></tr>
<tr class="separator:a6a312aa40e2b58167279881c1d14d62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33879f34f12f89054eff83437dd34f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab33879f34f12f89054eff83437dd34f0">symmetric_difference</a> (const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt; &amp;N1)</td></tr>
<tr class="memdesc:ab33879f34f12f89054eff83437dd34f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the symmectric difference <code>N - T</code> \( \cup\) <code>T - N</code>.  <a href="classCGAL_1_1Nef__polyhedron__2.html#ab33879f34f12f89054eff83437dd34f0">More...</a><br /></td></tr>
<tr class="separator:ab33879f34f12f89054eff83437dd34f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac5779dcd0d9aa9007e4bafe0bceb3ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5779dcd0d9aa9007e4bafe0bceb3ae4">&#9670;&nbsp;</a></span>Direction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unspecified_type <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ac5779dcd0d9aa9007e4bafe0bceb3ae4">Direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>directions in our plane. </p>

</div>
</div>
<a id="a1e0e9aa5868dc87384c1cb65df4b2828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0e9aa5868dc87384c1cb65df4b2828">&#9670;&nbsp;</a></span>Line</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unspecified_type <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a1e0e9aa5868dc87384c1cb65df4b2828">Line</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the oriented lines modeling halfplanes. </p>

</div>
</div>
<a id="a2ae6d7ad3ab6fa5417b87d9cfec493af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae6d7ad3ab6fa5417b87d9cfec493af">&#9670;&nbsp;</a></span>Object_handle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unspecified_type <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a generic handle to an object of the underlying plane map. </p>
<p>The kind of object <code>(vertex, halfedge, face)</code> can be determined and the object can be assigned to a corresponding handle by the three functions:</p>
<p><code>bool assign(Vertex_const_handle&amp; h, Object_handle)</code></p>
<p><code>bool assign(Halfedge_const_handle&amp; h, Object_handle)</code></p>
<p><code>bool assign(Face_const_handle&amp; h, Object_handle)</code></p>
<p>where each function returns <code>true</code> iff the assignment to <code>h</code> was done. </p>

</div>
</div>
<a id="a5dba79fcf624dbb9e3163f68f4f75e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dba79fcf624dbb9e3163f68f4f75e00">&#9670;&nbsp;</a></span>Point</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unspecified_type <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">Point</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the affine points of the plane. </p>

</div>
</div>
<a id="ac640be6a8130703344a89ad4859d4867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac640be6a8130703344a89ad4859d4867">&#9670;&nbsp;</a></span>Polygons_tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unspecified_type <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ac640be6a8130703344a89ad4859d4867">Polygons_tag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tag for calling polygon constructor. </p>

</div>
</div>
<a id="afa372c8392eae26070c04575ec8d198d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa372c8392eae26070c04575ec8d198d">&#9670;&nbsp;</a></span>Polylines_tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unspecified_type <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#afa372c8392eae26070c04575ec8d198d">Polylines_tag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tag for calling polyline constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a8cb9d4db15905d56ae4be1d502aab8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb9d4db15905d56ae4be1d502aab8ff">&#9670;&nbsp;</a></span>Boundary</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ff">CGAL::Nef_polyhedron_2::Boundary</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construction selection. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8cb9d4db15905d56ae4be1d502aab8ffa94a77215e20d6be276e5b7ec032c3139"></a>EXCLUDED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43"></a>INCLUDED&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ab5f1c19c50d23c0a759c2d2b1bb60bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f1c19c50d23c0a759c2d2b1bb60bd0">&#9670;&nbsp;</a></span>Content</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0">CGAL::Nef_polyhedron_2::Content</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construction selection </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab5f1c19c50d23c0a759c2d2b1bb60bd0a4786fccb661c483062e02b784e1c722c"></a>EMPTY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab5f1c19c50d23c0a759c2d2b1bb60bd0acbd2d7c6e526cfad582f001a6a0042a3"></a>COMPLETE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aa7cddcb2fffffe488f897da1f3cf4abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cddcb2fffffe488f897da1f3cf4abc">&#9670;&nbsp;</a></span>Location_mode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">CGAL::Nef_polyhedron_2::Location_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>selectionflag for the point location mode. </p>
<p>LMWT stands for Locally Minimum Weight Triangulation, a locally optimized constrained triangulation where the weight corresponds to the length of the edges of the triangulation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af"></a>DEFAULT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa7cddcb2fffffe488f897da1f3cf4abcaca828eed6da20a9383aeb13ef1dcdbed"></a>NAIVE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa7cddcb2fffffe488f897da1f3cf4abca775e12588827baac52ff0b8d3dec1616"></a>LMWT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab4af61958347b01b464fb87ce06d7571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4af61958347b01b464fb87ce06d7571">&#9670;&nbsp;</a></span>Nef_polyhedron_2() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0">Content</a>&#160;</td>
          <td class="paramname"><em>plane</em> = <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0a4786fccb661c483062e02b784e1c722c">EMPTY</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates an instance <code>N</code> of type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt;T&gt;</code> and initializes it to the empty set if <code>plane == EMPTY</code> and to the whole plane if <code>plane == COMPLETE</code>. </p>

</div>
</div>
<a id="a5c6718ebe574d776b5cc9c767eff9acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6718ebe574d776b5cc9c767eff9acf">&#9670;&nbsp;</a></span>Nef_polyhedron_2() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a1e0e9aa5868dc87384c1cb65df4b2828">Line</a>&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ff">Boundary</a>&#160;</td>
          <td class="paramname"><em>line</em> = <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43">INCLUDED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a Nef polyhedron <code>N</code> containing the halfplane left of <code>l</code> including <code>l</code> if <code>line==INCLUDED</code>, excluding <code>l</code> if <code>line==EXCLUDED</code>. </p>

</div>
</div>
<a id="ab97de249020e516c3e6a599f18a1f745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97de249020e516c3e6a599f18a1f745">&#9670;&nbsp;</a></span>Nef_polyhedron_2() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;class Forward_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a> </td>
          <td>(</td>
          <td class="paramtype">Forward_iterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Forward_iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ff">Boundary</a>&#160;</td>
          <td class="paramname"><em>b</em> = <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43">INCLUDED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a Nef polyhedron <code>N</code> from the simple polygon <code>P</code> spanned by the list of points in the iterator range <code>[it,end)</code> and including its boundary if <code>b = INCLUDED</code> excluding the boundary otherwise. </p>
<p><code>Forward_iterator</code> has to be an iterator with value type <code>Point</code>. This construction expects that <code>P</code> is simple. The degenerate cases where <code>P</code> contains no point, one point or spans just one segment (two points) are correctly handled. In all degenerate cases there's only one unbounded face adjacent to the degenerate polygon. If <code>b == INCLUDED</code> then <code>N</code> is just the boundary. If <code>b == EXCLUDED</code> then <code>N</code> is the whole plane without the boundary. </p>

</div>
</div>
<a id="ad68e86a3bdeddb587363bf73edaae184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68e86a3bdeddb587363bf73edaae184">&#9670;&nbsp;</a></span>Nef_polyhedron_2() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;class Forward_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a> </td>
          <td>(</td>
          <td class="paramtype">Forward_iterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Forward_iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ac640be6a8130703344a89ad4859d4867">Polygons_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The iterator range [it, end) defines a set point ranges, each of which defines the boundary of simple polygon. </p>

</div>
</div>
<a id="af756cab6f8712b0aaaeddb72f6115aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af756cab6f8712b0aaaeddb72f6115aee">&#9670;&nbsp;</a></span>Nef_polyhedron_2() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;class Forward_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a> </td>
          <td>(</td>
          <td class="paramtype">Forward_iterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Forward_iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#afa372c8392eae26070c04575ec8d198d">Polylines_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The iterator range [it, end) defines a set point ranges, each of which defines a polyline. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5caead26e295b819211f52c2e616b568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5caead26e295b819211f52c2e616b568">&#9670;&nbsp;</a></span>boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt;T&gt; <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::boundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the boundary of <code>N</code>. </p>

</div>
</div>
<a id="ad8a2c296b76e8bb29c715bbabac6654b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a2c296b76e8bb29c715bbabac6654b">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0">Content</a>&#160;</td>
          <td class="paramname"><em>plane</em> = <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0a4786fccb661c483062e02b784e1c722c">EMPTY</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>makes <code>N</code> the empty set if <code>plane == EMPTY</code> and the full plane if <code>plane == COMPLETE</code>. </p>

</div>
</div>
<a id="a7250e12e77f1d7e64a773243cb413b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7250e12e77f1d7e64a773243cb413b8f">&#9670;&nbsp;</a></span>closure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt;T&gt; <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::closure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the closure of <code>N</code>. </p>

</div>
</div>
<a id="a6d563177e49fd01a39e44f1183797a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d563177e49fd01a39e44f1183797a96">&#9670;&nbsp;</a></span>complement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt;T&gt; <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::complement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the complement of <code>N</code> in the plane. </p>

</div>
</div>
<a id="ae40387867733e7ddc47f5a29f33cac02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40387867733e7ddc47f5a29f33cac02">&#9670;&nbsp;</a></span>contained_in_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::contained_in_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true iff the object <code>h</code> is contained in the \( 1\)-skeleton of <code>N</code>. </p>

</div>
</div>
<a id="a8de0d51fb5bc6e9e73f87047fa0f1f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de0d51fb5bc6e9e73f87047fa0f1f3f">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true iff the object <code>h</code> is contained in the set represented by <code>N</code>. </p>

</div>
</div>
<a id="a6a312aa40e2b58167279881c1d14d62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a312aa40e2b58167279881c1d14d62f">&#9670;&nbsp;</a></span>difference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt;T&gt; <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>N1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns <code>N</code> \( -\) <code>N1</code>. </p>

</div>
</div>
<a id="a067bf42f1a6b9b13a6fcc45baa30299b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067bf42f1a6b9b13a6fcc45baa30299b">&#9670;&nbsp;</a></span>explorer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Explorer.html">Explorer</a> <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::explorer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a decorator object that allows read-only access of the underlying plane map. </p>
<p>See the manual page <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Explorer.html">Explorer</a></code> for its usage. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Nef_2_2nef_2_exploration_8cpp-example.html#a2">Nef_2/nef_2_exploration.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3b82c78fe42d878d9418023fe02590f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b82c78fe42d878d9418023fe02590f9">&#9670;&nbsp;</a></span>interior()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt;T&gt; <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::interior </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the interior of <code>N</code>. </p>

</div>
</div>
<a id="ab341639df2691491b20e8adf96b94d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab341639df2691491b20e8adf96b94d62">&#9670;&nbsp;</a></span>intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt;T&gt; <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>N1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns <code>N</code> \( \cap\) <code>N1</code>. </p>

</div>
</div>
<a id="a5014cbf16cdb80a88729b259741bf16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5014cbf16cdb80a88729b259741bf16f">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if <code>N</code> is empty, false otherwise. </p>

</div>
</div>
<a id="ada3ed3315cae400bdfdfcac4c9be5bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3ed3315cae400bdfdfcac4c9be5bce">&#9670;&nbsp;</a></span>is_plane()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::is_plane </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if <code>N</code> is the whole plane, false otherwise. </p>

</div>
</div>
<a id="acfd32f367b34bb3fd67028b61082888b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd32f367b34bb3fd67028b61082888b">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt;T&gt; <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>N1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns <code>N</code> \( \cup\) <code>N1</code>. </p>
<p>Note that "union" is a keyword of C++ and cannot be used for this operation. </p>

</div>
</div>
<a id="a1eca334fed696603f7bed85da151582c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eca334fed696603f7bed85da151582c">&#9670;&nbsp;</a></span>locate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a> <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::locate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">Location_mode</a>&#160;</td>
          <td class="paramname"><em>m</em> = <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af">DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a generic handle <code>h</code> to an object (face, halfedge, vertex) of the underlying plane map that contains the point <code>p</code> in its relative interior. </p>
<p>The point <code>p</code> is contained in the set represented by <code>N</code> if <code>N.contains(h)</code> is true. The location mode flag <code>m</code> allows one to choose between different point location strategies. </p>

</div>
</div>
<a id="a59903a8983c436a9be57e4bf9d49cfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59903a8983c436a9be57e4bf9d49cfd8">&#9670;&nbsp;</a></span>ray_shoot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a> <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::ray_shoot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ac5779dcd0d9aa9007e4bafe0bceb3ae4">Direction</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">Location_mode</a>&#160;</td>
          <td class="paramname"><em>m</em> = <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af">DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a handle <code>h</code> with <code>N.contains(h)</code>, that can be converted to a <code>Vertex_/Halfedge_/Face_const_handle</code> as described above. </p>
<p>The object returned is intersected by the ray starting in <code>p</code> with direction <code>d</code> and has minimal distance to <code>p</code>. The operation returns an empty <code>Object_handle</code> if the ray shoot along <code>d</code> does not hit any object <code>h</code> of <code>N</code> with <code>N.contains(h)</code>. The location mode flag <code>m</code> allows one to choose between different point location strategies. </p>

</div>
</div>
<a id="a7e858bf751d797d0299e312238bd0688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e858bf751d797d0299e312238bd0688">&#9670;&nbsp;</a></span>ray_shoot_to_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a> <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::ray_shoot_to_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ac5779dcd0d9aa9007e4bafe0bceb3ae4">Direction</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">Location_mode</a>&#160;</td>
          <td class="paramname"><em>m</em> = <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af">DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a handle <code>h</code>, that can be converted to a <code>Vertex_/Halfedge_const_handle</code> as described above. </p>
<p>The object returned is part of the \( 1\)-skeleton of <code>N</code>, intersected by the ray starting in <code>p</code> with direction <code>d</code> and has minimal distance to <code>p</code>. The operation returns an empty <code>Object_handle</code> if the ray shoot along <code>d</code> does not hit any \( 1\)-skeleton object <code>h</code> of <code>N</code>. The location mode flag <code>m</code> allows one to choose between different point location strategies. </p>

</div>
</div>
<a id="a1d0ed6d7b4eb2a47d449c097cdc5cfff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0ed6d7b4eb2a47d449c097cdc5cfff">&#9670;&nbsp;</a></span>regularization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt;T&gt; <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::regularization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the regularized polyhedron (closure of interior). </p>

</div>
</div>
<a id="ab33879f34f12f89054eff83437dd34f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33879f34f12f89054eff83437dd34f0">&#9670;&nbsp;</a></span>symmetric_difference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt;T&gt; <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>N1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the symmectric difference <code>N - T</code> \( \cup\) <code>T - N</code>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="astructCGAL_1_1Cartesian_html"><div class="ttname"><a href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Filtered__extended__homogeneous_html"><div class="ttname"><a href="classCGAL_1_1Filtered__extended__homogeneous.html">CGAL::Filtered_extended_homogeneous</a></div><div class="ttdef"><b>Definition:</b> Filtered_extended_homogeneous.h:20</div></div>
<div class="ttc" id="aclassCGAL_1_1Nef__polyhedron__2_html_a5dba79fcf624dbb9e3163f68f4f75e00"><div class="ttname"><a href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">CGAL::Nef_polyhedron_2::Point</a></div><div class="ttdeci">unspecified_type Point</div><div class="ttdoc">the affine points of the plane.</div><div class="ttdef"><b>Definition:</b> Nef_polyhedron_2.h:106</div></div>
<div class="ttc" id="astructCGAL_1_1Homogeneous_html"><div class="ttname"><a href="../Kernel_23/structCGAL_1_1Homogeneous.html">CGAL::Homogeneous</a></div></div>
<div class="ttc" id="agroup__nt__cgal_html_gae96d924c796bfc4e781d28f81df43c52"><div class="ttname"><a href="../Number_types/group__nt__cgal.html#gae96d924c796bfc4e781d28f81df43c52">CGAL::Exact_integer</a></div><div class="ttdeci">unspecified_type Exact_integer</div></div>
<div class="ttc" id="aclassCGAL_1_1Nef__polyhedron__2_html"><div class="ttname"><a href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a></div><div class="ttdef"><b>Definition:</b> Nef_polyhedron_2.h:92</div></div>
<div class="ttc" id="aExact__integer_8h.html_html"><div class="ttname"><a href="../Number_types/Exact__integer_8h.html">Exact_integer.h</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Nef__polyhedron__2_html_a1e0e9aa5868dc87384c1cb65df4b2828"><div class="ttname"><a href="classCGAL_1_1Nef__polyhedron__2.html#a1e0e9aa5868dc87384c1cb65df4b2828">CGAL::Nef_polyhedron_2::Line</a></div><div class="ttdeci">unspecified_type Line</div><div class="ttdoc">the oriented lines modeling halfplanes.</div><div class="ttdef"><b>Definition:</b> Nef_polyhedron_2.h:101</div></div>
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceCGAL.html">CGAL</a></li><li class="navelem"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</div>
</body>
</html>
