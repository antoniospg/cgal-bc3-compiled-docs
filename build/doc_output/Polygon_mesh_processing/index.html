<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CGAL 5.1 - Polygon Mesh Processing: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
      }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png"
           onmouseover="return searchBox.OnSearchSelectShow()"
           onmouseout="return searchBox.OnSearchSelectHide()"
           alt=""/>
      <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)"
             onblur="searchBox.OnSearchFieldFocus(false)"
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt=""/></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.1 - Polygon Mesh Processing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_PolygonMeshProcessing"></a> </p> <div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Sébastien Loriot, Mael Rouxel-Labbé, Jane Tournois, Ilker O. Yaz</dd></dl>
<div class="image">
<img src="neptun_head.jpg" alt=""/>
</div>
<p>  <br  />
</p>
<h1><a class="anchor" id="PMPIntroduction"></a>
Introduction</h1>
<p>This package implements a collection of methods and classes for polygon mesh processing, ranging from basic operations on simplices, to complex geometry processing algorithms. The implementation of this package mainly follows algorithms and references given in Botsch et al.'s book on polygon mesh processing <a class="el" href="citelist.html#CITEREF_botsch2010PMP">[4]</a>.</p>
<h2><a class="anchor" id="PMPDef"></a>
Polygon Mesh</h2>
<p>A <em>polygon</em> <em>mesh</em> is a consistent and orientable surface mesh, that can have one or more boundaries. The <em>faces</em> are simple polygons. The <em>edges</em> are segments. Each edge connects two <em>vertices</em>, and is shared by two faces (including the <em>null</em> <em>face</em> for boundary edges). A polygon mesh can have any number of connected components, and also some self-intersections. In this package, a polygon mesh is considered to have the topology of a 2-manifold.</p>
<h2><a class="anchor" id="PMPAPI"></a>
API</h2>
<p>This package follows the BGL API described in PkgBGL. It can thus be used either with <code><a class="elRef" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code>, <code><a class="elRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code>, or any class model of the concept <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code>. Each function or class of this package details the requirements on the input polygon mesh.</p>
<p><a class="elRef" href="../BGL/index.html#BGLNamedParameters">Named Parameters</a> are used to deal with optional parameters. The page <a class="el" href="group__pmp__namedparameters.html">Named Parameters for Polygon Mesh Processing</a> describes their usage and provides a list of the parameters that are used in this package.</p>
<h2><a class="anchor" id="PMPOutline"></a>
Outline</h2>
<p>The algorithms described in this manual are organized in sections:</p><ul>
<li><a class="el" href="index.html#PMPMeshing">Meshing</a> : meshing algorithms, including triangulation of non-triangulated meshes, refinement, optimization by fairing, isotropic remeshing of triangulated surface meshes and smoothing algorithms.</li>
<li><a class="el" href="index.html#Coref_section">Corefinement and Boolean Operations</a> : methods to corefine triangle meshes and to compute boolean operations out of corefined closed triangle meshes.</li>
<li><a class="el" href="index.html#PMPHoleFilling">Hole Filling</a> : available hole filling algorithms, which can possibly be combined with refinement and fairing.</li>
<li><a class="el" href="index.html#PMPPredicates">Predicates</a> : predicates that can be evaluated on the processed polygon. mesh, which includes point location and self intersection tests.</li>
<li><a class="el" href="index.html#PMPOrientation">Orientation</a> : checking or fixing the orientation of a polygon soup.</li>
<li><a class="el" href="index.html#PMPRepairing">Combinatorial Repairing</a> : repair of polygon meshes and polygon soups.</li>
<li><a class="el" href="index.html#PMPNormalComp">Computing Normals</a> : normal computation at vertices and on faces of a polygon mesh.</li>
<li><a class="el" href="index.html#PMPSlicer">Slicer</a> : functor able to compute the intersections of a polygon mesh with arbitrary planes (slicer).</li>
<li><a class="el" href="index.html#PMPConnectedComponents">Connected Components</a> : methods to deal with connected components of a polygon mesh (extraction, marks, removal, ...).</li>
</ul>
<h1><a class="anchor" id="PMPMeshing"></a>
Meshing</h1>
<p>A surface patch can be refined by inserting new vertices and flipping edges to get a triangulation. Using a criterion presented in <a class="el" href="citelist.html#CITEREF_liepa2003filling">[9]</a>, the density of triangles near the boundary of the patch is approximated by the refinement function. The validity of the mesh is enforced by flipping edges. An edge is flipped only if the opposite edge does not exist in the original mesh and if no degenerate triangles are generated.</p>
<p>A region of the surface mesh (<em>e</em>.<em>g</em>. the refined region), can be faired to obtain a tangentially continuous and smooth surface patch. The region to be faired is defined as a range of vertices that are relocated. The fairing step minimizes a linear bi-Laplacian system with boundary constraints, described in <a class="el" href="citelist.html#CITEREF_Botsch2008OnLinearVariational">[3]</a>. The visual results of aforementioned steps are depicted by <a class="el" href="index.html#fig__Mech_steps">fig__Mech_steps</a> (c and d).</p>
<h2><a class="anchor" id="MeshingAPI"></a>
API</h2>
<h3><a class="anchor" id="Meshing"></a>
Meshing</h3>
<p>Refinement and fairing functions can be applied to an arbitrary region on a triangle mesh, using :</p><ul>
<li><code><a class="el" href="group__PMP__meshing__grp.html#gad0449d8e1021fc46507074cd6db65ef4" title="refines a region of a triangle mesh">CGAL::Polygon_mesh_processing::refine()</a></code> : given a set of facets on a mesh, refines the region.</li>
<li><code><a class="el" href="group__PMP__meshing__grp.html#gaa091c8368920920eed87784107d68ecf" title="fairs a region on a triangle mesh. The points of the selected vertices are relocated to yield an as-s...">CGAL::Polygon_mesh_processing::fair()</a></code> : given a set of vertices on a mesh, fairs the region.</li>
</ul>
<p>Fairing needs a sparse linear solver and we recommend the use of thirdpartyEigen 3.2 or later. Note that fairing might fail if fixed vertices, which are used as boundary conditions, do not suffice to solve the constructed linear system.</p>
<p>Many algorithms require as input meshes in which all the faces have the same degree, or even are triangles. Hence, one may want to triangulate all polygon faces of a mesh.</p>
<p>This package provides the function <code><a class="el" href="group__PMP__meshing__grp.html#gacaaff4d520500c530d9c3d5ebe2a0760">CGAL::Polygon_mesh_processing::triangulate_faces()</a></code> that triangulates all faces of the input polygon mesh. An approximated support plane is chosen for each face, orthogonal to the normal vector computed by <code><a class="el" href="group__PMP__normal__grp.html#gaa76c6d307b9d3e48cafacd7b77b2c043">CGAL::Polygon_mesh_processing::compute_face_normal()</a></code>. Then, the triangulation of each face is the one obtained by building a <code><a class="elRef" href="../Triangulation_2/classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2</a></code> in this plane. This choice is made because the constrained Delaunay triangulation is the triangulation that, given the edges of the face to be triangulated, maximizes the minimum angle of all the angles of the triangles in the triangulation.</p>
<h3><a class="anchor" id="Remeshing"></a>
Remeshing</h3>
<p>The incremental triangle-based isotropic remeshing algorithm introduced by Botsch et al <a class="el" href="citelist.html#CITEREF_botsch2004remeshing">[2]</a>, <a class="el" href="citelist.html#CITEREF_botsch2010PMP">[4]</a> is implemented in this package. This algorithm incrementally performs simple operations such as edge splits, edge collapses, edge flips, and Laplacian smoothing. All the vertices of the remeshed patch are reprojected to the original surface to keep a good approximation of the input.</p>
<p>A triangulated region of a polygon mesh can be remeshed using the function <code><a class="el" href="group__PMP__meshing__grp.html#gad3d03890515ae8103bd32a30a3486412" title="remeshes a triangulated region of a polygon mesh. This operation sequentially performs edge splits,...">CGAL::Polygon_mesh_processing::isotropic_remeshing()</a></code>, as illustrated by <a class="el" href="index.html#fig__iso_remeshing">fig__iso_remeshing</a>. The algorithm has only two parameters : the target edge length for the remeshed surface patch, and the number of iterations of the abovementioned sequence of operations. The bigger this number, the smoother and closer to target edge length the mesh will be.</p>
<p>An additional option has been added to <em>protect</em> (<em>i</em>.<em>e</em>. not modify) some given polylines. In some cases, those polylines are too long, and reaching the desired target edge length while protecting them is not possible and leads to an infinite loop of edge splits in the incident faces. To avoid that pitfall, the function <code><a class="el" href="group__PMP__meshing__grp.html#gaafd017f4424c3942bfdcc93874c8f596" title="splits the edges listed in edges into sub-edges that are not longer than the given threshold max_leng...">CGAL::Polygon_mesh_processing::split_long_edges()</a></code> should be called on the list of constrained edges before remeshing.</p>
<p><a class="anchor" id="fig__iso_remeshing"></a></p><div class="image">
<img src="iso_remeshing.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__iso_remeshing">fig__iso_remeshing</a> Isotropic remeshing. (a) Triangulated input surface mesh. (b) Surface uniformly and entirely remeshed. (c) Selection of a range of faces to be remeshed. (d) Surface mesh with the selection uniformly remeshed. </p> </div> <p> <br  />
</p>
<h3><a class="anchor" id="Smoothing"></a>
Smoothing</h3>
<p>Smoothing of a triangulated mesh region can be achieved with algorithms that aim at either mesh smoothing or shape smoothing. While mesh smoothing is achieved by improving the quality of triangles based on criteria such as angle and area, shape smoothing is designed to be <em>intrinsic</em>, depending as little as possible on the discretization and smoothing the shape alone without optimizing the shape of the triangles.</p>
<ul>
<li>Mesh smoothing: <code><a class="el" href="group__PMP__meshing__grp.html#gaa0551d546f6ab2cd9402bea12d8332a3" title="smoothes a triangulated region of a polygon mesh.">CGAL::Polygon_mesh_processing::smooth_mesh()</a></code> moves vertices to optimize geometry around each vertex: it can try to equalize the angles between incident edges, or (and) move vertices so that areas of adjacent triangles tend to equalize. Border vertices are considered constrained and do not move at any step of the procedure. No vertices are inserted at any time. Angle and area smoothing algorithms are based on Surazhsky and Gotsman <a class="el" href="citelist.html#CITEREF_cgal:sg-hqct-04">[10]</a>. Since area smoothing considers only areas as a smoothing criterion, it may result in long and skinny triangles. To paliate this phenomenon, area smoothing is followed by an (optional) step of Delaunay-based edge flips. In any case, area smoothing is guaranteed to improve the spatial distribution of the vertices over the area that is being smoothed. A simple example can be found in <a class="el" href="Polygon_mesh_processing_2mesh_smoothing_example_8cpp-example.html">Polygon_mesh_processing/mesh_smoothing_example.cpp</a>.</li>
</ul>
<p><a class="anchor" id="fig__PMPFigMeshSmoothing"></a></p><center> <img src="mesh_smoothing.png" alt="" style="max-width:70%;" class="inline"/> </center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__PMPFigMeshSmoothing">fig__PMPFigMeshSmoothing</a> Mesh smoothing of the closed surface <em>blobby</em>, containing self-intersections (circled in red). For each smoothing combination, 10 iterations were applied. From left to right: (a) Input mesh; (b) Smoothing based on areas without using Delaunay flips; (c) Smoothing based on areas with Delaunay flips; (d) Smoothing based on angles; (e) Smoothing based on angles and areas, with Delaunay flips. </p> </div> <p> <br  />
</p>
<p><a class="anchor" id="fig__Fig_smooth_stats"></a></p><div class="image">
<img src="smooth_statistics.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__Fig_smooth_stats">fig__Fig_smooth_stats</a> Statistics for the various combinations of mesh smoothing. </p> </div> <p> <br  />
</p>
<ul>
<li>Shape smoothing: <code><a class="el" href="group__PMP__meshing__grp.html#gaaa083ec78bcecf351e04d1bbf460b4a2">CGAL::Polygon_mesh_processing::smooth_shape()</a></code> incrementally moves vertices towards a weighted barycenter of their neighbors along the mean curvature flow. The curvature flow algorithm for shape smoothing is based on Desbrun et al. <a class="el" href="citelist.html#CITEREF_cgal:dmsb-ifamdcf-99">[6]</a> and on Kazhdan et al. <a class="el" href="citelist.html#CITEREF_kazhdan2012can">[8]</a>. The algorithm uses the mean curvature flow to calculate the translation of vertices along the surface normal with a speed equal to the mean curvature of the area that is being smoothed. This means that vertices on sharp corners slide faster. If the region around a vertex is flat, this vertex does not move (zero curvature). To avoid the formation of undesirable neck pinches (cylindrical surface areas that form singularities) the algorithm slows down the evolution in cylindrical regions. The smoothed shape converges to a sphere while staying conformally equivalent to its original shape. A simple example can be found in <a class="el" href="Polygon_mesh_processing_2shape_smoothing_example_8cpp-example.html">Polygon_mesh_processing/shape_smoothing_example.cpp</a>.</li>
</ul>
<p><a class="anchor" id="fig__PMPFigShapeSmoothing"></a></p><center> <img src="shape_smoothing.png" alt="" style="max-width:70%;" class="inline"/> </center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__PMPFigShapeSmoothing">fig__PMPFigShapeSmoothing</a> Shape smoothing of the devil model, using the mean curvature flow with a time step equal to 0.05 and constraining border vertices (located at the neck, where the mesh is open). </p> </div> <p> <br  />
</p>
<h2><a class="anchor" id="MeshingExamples"></a>
Meshing Examples</h2>
<h3><a class="anchor" id="MeshingExample_1"></a>
Refine and Fair a Region on a Triangle Mesh</h3>
<p>The following example calls the functions <code><a class="el" href="group__PMP__meshing__grp.html#gad0449d8e1021fc46507074cd6db65ef4" title="refines a region of a triangle mesh">CGAL::Polygon_mesh_processing::refine()</a></code> and <code><a class="el" href="group__PMP__meshing__grp.html#gaa091c8368920920eed87784107d68ecf" title="fairs a region on a triangle mesh. The points of the selected vertices are relocated to yield an as-s...">CGAL::Polygon_mesh_processing::fair()</a></code> for some selected regions on the input triangle mesh.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2refine_fair_example_8cpp-example.html">Polygon_mesh_processing/refine_fair_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/refine.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/fair.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="codeRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>  Polyhedron;</div>
<div class="line"><span class="keyword">typedef</span> Polyhedron::Vertex_handle   Vertex_handle;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// extract vertices which are at most k (inclusive)</span></div>
<div class="line"><span class="comment">// far from vertex v in the graph of edges</span></div>
<div class="line"><span class="keywordtype">void</span> extract_k_ring(Vertex_handle v,</div>
<div class="line">                    <span class="keywordtype">int</span> k,</div>
<div class="line">                    std::vector&lt;Vertex_handle&gt;&amp; qv)</div>
<div class="line">{</div>
<div class="line">  std::map&lt;Vertex_handle, int&gt;  D;</div>
<div class="line">  qv.push_back(v);</div>
<div class="line">  D[v] = 0;</div>
<div class="line">  std::size_t current_index = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> dist_v;</div>
<div class="line">  <span class="keywordflow">while</span> (current_index &lt; qv.size() &amp;&amp; (dist_v = D[qv[current_index]]) &lt; k)</div>
<div class="line">  {</div>
<div class="line">    v = qv[current_index++];</div>
<div class="line"> </div>
<div class="line">    Polyhedron::Halfedge_around_vertex_circulator e(v-&gt;vertex_begin()), e_end(e);</div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">      Vertex_handle new_v = e-&gt;opposite()-&gt;vertex();</div>
<div class="line">      <span class="keywordflow">if</span> (D.insert(std::make_pair(new_v, dist_v + 1)).second) {</div>
<div class="line">        qv.push_back(new_v);</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">while</span> (++e != e_end);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/blobby.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line"> </div>
<div class="line">  Polyhedron poly;</div>
<div class="line">  <span class="keywordflow">if</span> ( !input || !(input &gt;&gt; poly) || poly.empty()</div>
<div class="line">              || !<a class="codeRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(poly)) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Not a valid input file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Polyhedron::Facet_handle&gt;  new_facets;</div>
<div class="line">  std::vector&lt;Vertex_handle&gt; new_vertices;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__PMP__meshing__grp.html#gad0449d8e1021fc46507074cd6db65ef4">CGAL::Polygon_mesh_processing::refine</a>(poly,</div>
<div class="line">                  faces(poly),</div>
<div class="line">                  std::back_inserter(new_facets),</div>
<div class="line">                  std::back_inserter(new_vertices),</div>
<div class="line">                  CGAL::Polygon_mesh_processing::parameters::density_control_factor(2.));</div>
<div class="line"> </div>
<div class="line">  std::ofstream refined_off(<span class="stringliteral">&quot;refined.off&quot;</span>);</div>
<div class="line">  refined_off.precision(17);</div>
<div class="line">  refined_off &lt;&lt; poly;</div>
<div class="line">  refined_off.close();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement added &quot;</span> &lt;&lt; new_vertices.size() &lt;&lt; <span class="stringliteral">&quot; vertices.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  Polyhedron::Vertex_iterator v = poly.vertices_begin();</div>
<div class="line">  std::advance(v, 82<span class="comment">/*e.g.*/</span>);</div>
<div class="line">  std::vector&lt;Vertex_handle&gt; region;</div>
<div class="line">  extract_k_ring(v, 12<span class="comment">/*e.g.*/</span>, region);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> success = <a class="code" href="group__PMP__meshing__grp.html#gaa091c8368920920eed87784107d68ecf">CGAL::Polygon_mesh_processing::fair</a>(poly, region);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Fairing : &quot;</span> &lt;&lt; (success ? <span class="stringliteral">&quot;succeeded&quot;</span> : <span class="stringliteral">&quot;failed&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::ofstream faired_off(<span class="stringliteral">&quot;faired.off&quot;</span>);</div>
<div class="line">  faired_off.precision(17);</div>
<div class="line">  faired_off &lt;&lt; poly;</div>
<div class="line">  faired_off.close();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="MeshingExample_2"></a>
Triangulate a Polygon Mesh</h3>
<p>Triangulating a polygon mesh can be achieved through the function <code><a class="el" href="group__PMP__meshing__grp.html#gacaaff4d520500c530d9c3d5ebe2a0760">CGAL::Polygon_mesh_processing::triangulate_faces()</a></code> as shown in the following example.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2triangulate_faces_example_8cpp-example.html">Polygon_mesh_processing/triangulate_faces_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_faces.h&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="codeRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                    Point;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>          Surface_mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/P.off&quot;</span>;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* outfilename = (argc &gt; 2) ? argv[2] : <span class="stringliteral">&quot;P_tri.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line"> </div>
<div class="line">  Surface_mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh) || mesh.is_empty())</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Not a valid off file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__PMP__meshing__grp.html#gacaaff4d520500c530d9c3d5ebe2a0760">CGAL::Polygon_mesh_processing::triangulate_faces</a>(mesh);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Confirm that all faces are triangles.</span></div>
<div class="line">  <span class="keywordflow">for</span>(boost::graph_traits&lt;Surface_mesh&gt;::face_descriptor fit : faces(mesh))</div>
<div class="line">    <span class="keywordflow">if</span> (next(next(halfedge(fit, mesh), mesh), mesh)</div>
<div class="line">        !=   prev(halfedge(fit, mesh), mesh))</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: non-triangular face left in mesh.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::ofstream cube_off(outfilename);</div>
<div class="line">  cube_off.precision(17);</div>
<div class="line">  cube_off &lt;&lt; mesh;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="RemeshingExample_1"></a>
Isotropic Remeshing of a Region on a Polygon Mesh</h3>
<p>The following example shows a complete example of how the isotropic remeshing function can be used. First, the border of the polygon mesh is collected. Since the boundary edges will be considered as constrained and protected in this example, the function <code><a class="el" href="group__PMP__meshing__grp.html#gaafd017f4424c3942bfdcc93874c8f596" title="splits the edges listed in edges into sub-edges that are not longer than the given threshold max_leng...">split_long_edges()</a></code> is called first on these edges.</p>
<p>Once this is done, remeshing is run on all the surface, with protection of constraints activated, for 3 iterations.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2isotropic_remeshing_example_8cpp-example.html">Polygon_mesh_processing/isotropic_remeshing_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/remesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/border.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;boost/function_output_iterator.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a> Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::halfedge_descriptor halfedge_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::edge_descriptor     edge_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>halfedge2edge</div>
<div class="line">{</div>
<div class="line">  halfedge2edge(<span class="keyword">const</span> Mesh&amp; m, std::vector&lt;edge_descriptor&gt;&amp; edges)</div>
<div class="line">    : m_mesh(m), m_edges(edges)</div>
<div class="line">  {}</div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> halfedge_descriptor&amp; h)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    m_edges.push_back(edge(h, m_mesh));</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">const</span> Mesh&amp; m_mesh;</div>
<div class="line">  std::vector&lt;edge_descriptor&gt;&amp; m_edges;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/pig.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh) || !<a class="codeRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh)) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Not a valid input file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> target_edge_length = 0.04;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_iter = 3;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Split border...&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;edge_descriptor&gt; border;</div>
<div class="line">    <a class="code" href="group__PkgPolygonMeshProcessingRef.html#ga6f02a9031838b5b3436128d9ac3da26e">PMP::border_halfedges</a>(faces(mesh),</div>
<div class="line">      mesh,</div>
<div class="line">      boost::make_function_output_iterator(halfedge2edge(mesh, border)));</div>
<div class="line">    <a class="code" href="group__PMP__meshing__grp.html#gaafd017f4424c3942bfdcc93874c8f596">PMP::split_long_edges</a>(border, target_edge_length, mesh);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Start remeshing of &quot;</span> &lt;&lt; filename</div>
<div class="line">    &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; num_faces(mesh) &lt;&lt; <span class="stringliteral">&quot; faces)...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__PMP__meshing__grp.html#gad3d03890515ae8103bd32a30a3486412">PMP::isotropic_remeshing</a>(</div>
<div class="line">      faces(mesh),</div>
<div class="line">      target_edge_length,</div>
<div class="line">      mesh,</div>
<div class="line">      PMP::parameters::number_of_iterations(nb_iter)</div>
<div class="line">      .protect_constraints(<span class="keyword">true</span>)<span class="comment">//i.e. protect border, here</span></div>
<div class="line">      );</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Remeshing done.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="Coref_section"></a>
Corefinement and Boolean Operations</h1>
<h2><a class="anchor" id="coref_def_subsec"></a>
Definitions</h2>
<p><b>Corefinement</b> Given two triangulated surface meshes, the <em>corefinement</em> operation consists in refining both meshes so that their intersection polylines are a subset of edges in both refined meshes. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>more information on coplanar patches.</dd></dl>
<p><a class="anchor" id="fig__coref_fig"></a></p><div class="image">
<img src="corefine.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__coref_fig">fig__coref_fig</a> Corefinement of two triangulated surface meshes. (Left) Input meshes; (Right) The two input meshes corefined. The common edges of the two meshes are drawn in green. </p> </div> <p> <br  />
</p>
<p><b>Volume bounded by a triangulated surface mesh</b> Given a closed triangulated surface mesh, each connected component splits the 3D space into two subspaces. The vertex sequence of each face of a component is seen either clockwise or counterclockwise from these two subspaces. The subspace that sees the sequence clockwise (resp. counterclockwise) is on the negative (resp. positive) side of the component. Given a closed triangulated surface mesh <code>tm</code> with no self-intersections, the connected components of <code>tm</code> divide the 3D space into subspaces. We say that <code>tm</code> bounds a volume if each subspace lies exclusively on the positive (or negative) side of all the incident connected components of <code>tm</code>. The volume bounded by <code>tm</code> is the union of all subspaces that are on negative sides of their incident connected components of <code>tm</code>.</p>
<p><a class="anchor" id="fig__boundedvol_fig"></a></p><div class="image">
<img src="bounded_vols.jpg" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__boundedvol_fig">fig__boundedvol_fig</a> Volumes bounded by a triangulated surface mesh: The figure shows meshes representing three nested spheres (three connected components). The left side of the picture shows a clipped triangulated surface mesh, with the two possible orientations of the faces for which a volume is bounded by the mesh. The positive and negative sides of each connected component is displayed in light and dark blue, respectively. The right part of the picture shows clipped tetrahedral meshes of the corresponding bounded volumes. </p> </div> <p> <br  />
</p>
<h2><a class="anchor" id="coref_coref_subsec"></a>
Corefinement</h2>
<p>The corefinement of two triangulated surface meshes can be done using the function <code><a class="el" href="group__PMP__corefinement__grp.html#ga6447dee822aaf92016f34512ce0b3456">CGAL::Polygon_mesh_processing::corefine()</a></code>. It takes as input the two triangulated surface meshes to corefine. If constrained edge maps are provided, edges belonging to the intersection of the input meshes will be marked as constrained. In addition, if an edge that was marked as constrained is split during the corefinement, sub-edges will be marked as constrained as well.</p>
<h2><a class="anchor" id="coref_bolop_subsec"></a>
Boolean Operations</h2>
<p><a class="anchor" id="fig__boolop_fig"></a></p><div class="image">
<img src="bool_op.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__boolop_fig">fig__boolop_fig</a> Let <code>C</code> and <code>S</code> be the volumes bounded by the triangulated surface meshes of a cube and a sphere, respectively. From left to right, the picture shows the triangulated surface meshes bounding the union of <code>C</code> and <code>S</code>, <code>C</code> minus <code>S</code>, the intersection of <code>C</code> and <code>S</code> and <code>S</code> minus <code>C</code>. </p> </div> <p> <br  />
</p>
<p>The corefinement of two triangulated surface meshes can naturally be used for computing Boolean operations on volumes. Considering two triangulated surface meshes, each bounding a volume, the functions <code><a class="el" href="group__PMP__corefinement__grp.html#gad7e1741a7ce41a5846cf86494982ca8b">CGAL::Polygon_mesh_processing::corefine_and_compute_union()</a></code>, <code><a class="el" href="group__PMP__corefinement__grp.html#ga240e5df984c7d44741a7031e38203dc3">CGAL::Polygon_mesh_processing::corefine_and_compute_intersection()</a></code> and <code><a class="el" href="group__PMP__corefinement__grp.html#gac5a853c33c4b0a9da9403c9b191caa44">CGAL::Polygon_mesh_processing::corefine_and_compute_difference()</a></code> respectively compute the union, the intersection and the difference of the two volumes. If several Boolean operations must be computed at the same time, the function <code><a class="el" href="group__PMP__corefinement__grp.html#gadff4c3765726a9e4735ca391bb53b435">corefine_and_compute_boolean_operations()</a></code> should be used.</p>
<p>There is no restriction on the topology of the input volumes. However, there are some requirements on the input to guarantee that the operation is possible. First, the input meshes must not self-intersect. Second, the operation is possible only if the output can be bounded by a manifold triangulated surface mesh. In particular this means that the output volume has no part with zero thickness. Mathematically speaking, the intersection with an infinitesimally small ball centered in the output volume is a topological ball. At the surface level this means that no non-manifold vertex or edge is allowed in the output. For example, it is not possible to compute the union of two cubes that are disjoint but sharing an edge. In case you have to deal with such scenarios, you should consider using the package PkgNef3.</p>
<p>It is possible to update the input so that it contains the result (in-place operation). In that case the whole mesh will not be copied and only the region around the intersection polyline will be modified. In case the Boolean operation is not possible, the input mesh will nevertheless be corefined.</p>
<h2><a class="anchor" id="coref_valid_subsec"></a>
Kernel and Validity of the Output</h2>
<p>The corefinement operation (which is also internally used in the three Boolean operations) will correctly change the topology of the input surface mesh if the point type used in the point property maps of the input meshes is from a <span style="font-variant: small-caps;">CGAL</span> <a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a> with exact predicates. If that kernel does not have exact constructions, the embedding of the output surface mesh might have self-intersections. In case of consecutive operations, it is thus recommended to use a point property map with points from a kernel with exact predicates and exact constructions (such as <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a></code>).</p>
<p>In practice, this means that with exact predicates and inexact constructions, edges will be split at each intersection with a triangle but the position of the intersection point might create self-intersections due to the limited precision of floating point numbers.</p>
<h2><a class="anchor" id="coref_clip"></a>
Clipping</h2>
<p>As a natural extension, some clipping functionalities with a volume bounded by a closed mesh and a halfspace (defined by the negative side of a plane to be consistent with the outward normal convention) are offered. The functions <code><a class="el" href="group__PMP__corefinement__grp.html#ga30082762ba2d947cba304e2884d96a99">CGAL::Polygon_mesh_processing::clip()</a></code> and <code><a class="el" href="group__PMP__corefinement__grp.html#gaa491feee9e41f725332bea0ea1215578">CGAL::Polygon_mesh_processing::split()</a></code> have some options to select whether the clipping should be done at the volume or surface level, and also if the clipper should be considered as compact or not. This is illustrated on <a class="el" href="index.html#fig__coref_clip_close_open">fig__coref_clip_close_open</a> and <a class="el" href="index.html#fig__coref_clip_compact">fig__coref_clip_compact</a>.</p>
<p><a class="anchor" id="fig__coref_clip_close_open"></a></p><div class="image">
<img src="clip_open_close.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__coref_clip_close_open">fig__coref_clip_close_open</a> Clipping a cube with a halfspace. From left to right: (i) initial cube and the plane defining the clipping halfspace; (ii) <code>clip_volume=false</code>: clipping of the surface mesh (boundary edges depicted in red); (iii) <code>clip_volume=true</code>: clipping of the volume bounded by the surface mesh. </p> </div> <p> <br  />
</p>
<p><a class="anchor" id="fig__coref_clip_compact"></a></p><div class="image">
<img src="clip_compact.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__coref_clip_compact">fig__coref_clip_compact</a> Clipping a cube with a halfspace: compacity of the clipper (<code>clip_volume=false</code> in both cases). From left to right: (i) initial cube and the plane defining the clipping halfspace, note that a whole face of the cube (2 triangles) is exactly contained in the plane; (ii) <code>use_compact_clipper=true</code>: clipping of the surface mesh with a compact halfspace: coplanar faces are part of the output; (iii) <code>use_compact_clipper=false</code>: clipping of the surface mesh with a non-compact halfspace: coplanar faces are not part of the output. </p> </div> <p> <br  />
</p>
<h2><a class="anchor" id="coref_ex_subsec"></a>
Examples</h2>
<h3><a class="anchor" id="coref_ex_union_subsec"></a>
Computing the Union of Two Volumes</h3>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2corefinement_mesh_union_8cpp-example.html">Polygon_mesh_processing/corefinement_mesh_union.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/corefinement.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>             Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename1 = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/blobby.off&quot;</span>;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename2 = (argc &gt; 2) ? argv[2] : <span class="stringliteral">&quot;data/eight.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename1);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh1, mesh2;</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh1))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;First mesh is not a valid off file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line">  input.close();</div>
<div class="line">  input.open(filename2);</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh2))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Second mesh is not a valid off file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  Mesh out;</div>
<div class="line">  <span class="keywordtype">bool</span> valid_union = <a class="code" href="group__PMP__corefinement__grp.html#gad7e1741a7ce41a5846cf86494982ca8b">PMP::corefine_and_compute_union</a>(mesh1,mesh2, out);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (valid_union)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Union was successfully computed\n&quot;</span>;</div>
<div class="line">    std::ofstream output(<span class="stringliteral">&quot;union.off&quot;</span>);</div>
<div class="line">    output.precision(17);</div>
<div class="line">    output &lt;&lt; out;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Union could not be computed\n&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="coref_ex_refine_subsec"></a>
Boolean Operation and Local Remeshing</h3>
<p>This example is similar to the previous one, but here we substract a volume and update the first input triangulated surface mesh (in-place operation). The edges that are on the intersection of the input meshes are marked and the region around them is remeshed isotropically while preserving the intersection polyline. <br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2corefinement_difference_remeshed_8cpp-example.html">Polygon_mesh_processing/corefinement_difference_remeshed.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/corefinement.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/remesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/selection.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>             Mesh;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::edge_descriptor edge_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor face_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::halfedge_descriptor halfedge_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"><span class="keyword">namespace </span>params = PMP::parameters;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Vector_pmap_wrapper{</div>
<div class="line">  std::vector&lt;bool&gt;&amp; vect;</div>
<div class="line">  Vector_pmap_wrapper(std::vector&lt;bool&gt;&amp; v) : vect(v) {}</div>
<div class="line">  <span class="keyword">friend</span> <span class="keywordtype">bool</span> get(<span class="keyword">const</span> Vector_pmap_wrapper&amp; m, face_descriptor f)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> m.vect[f];</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">friend</span> <span class="keywordtype">void</span> put(<span class="keyword">const</span> Vector_pmap_wrapper&amp; m, face_descriptor f, <span class="keywordtype">bool</span> b)</div>
<div class="line">  {</div>
<div class="line">    m.vect[f]=b;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename1 = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/blobby.off&quot;</span>;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename2 = (argc &gt; 2) ? argv[2] : <span class="stringliteral">&quot;data/eight.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename1);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh1, mesh2;</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh1))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;First mesh is not a valid off file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line">  input.close();</div>
<div class="line">  input.open(filename2);</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh2))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Second mesh is not a valid off file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//create a property on edges to indicate whether they are constrained</span></div>
<div class="line">  Mesh::Property_map&lt;edge_descriptor,bool&gt; is_constrained_map =</div>
<div class="line">    mesh1.add_property_map&lt;edge_descriptor,<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;e:is_constrained&quot;</span>, <span class="keyword">false</span>).first;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// update mesh1 to contain the mesh bounding the difference</span></div>
<div class="line">  <span class="comment">// of the two input volumes.</span></div>
<div class="line">  <span class="keywordtype">bool</span> valid_difference =</div>
<div class="line">    <a class="code" href="group__PMP__corefinement__grp.html#gac5a853c33c4b0a9da9403c9b191caa44">PMP::corefine_and_compute_difference</a>(mesh1,</div>
<div class="line">                                         mesh2,</div>
<div class="line">                                         mesh1,</div>
<div class="line">                                         params::all_default(), <span class="comment">// default parameters for mesh1</span></div>
<div class="line">                                         params::all_default(), <span class="comment">// default parameters for mesh2</span></div>
<div class="line">                                         params::edge_is_constrained_map(is_constrained_map));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (valid_difference)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Difference was successfully computed\n&quot;</span>;</div>
<div class="line">    std::ofstream output(<span class="stringliteral">&quot;difference.off&quot;</span>);</div>
<div class="line">    output.precision(17);</div>
<div class="line">    output &lt;&lt; mesh1;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span>{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Difference could not be computed\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// collect faces incident to a constrained edge</span></div>
<div class="line">  std::vector&lt;face_descriptor&gt; selected_faces;</div>
<div class="line">  std::vector&lt;bool&gt; is_selected(num_faces(mesh1), <span class="keyword">false</span>);</div>
<div class="line">  <span class="keywordflow">for</span>(edge_descriptor e : edges(mesh1))</div>
<div class="line">    <span class="keywordflow">if</span> (is_constrained_map[e])</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// insert all faces incident to the target vertex</span></div>
<div class="line">      <span class="keywordflow">for</span>(halfedge_descriptor h :</div>
<div class="line">                    <a class="codeRef" href="../BGL/group__PkgBGLIterators.html#ga2be4fd4d24b1e48e00a92f90f0f2923c">halfedges_around_target</a>(halfedge(e,mesh1),mesh1))</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">if</span> (!<a class="codeRef" href="../BGL/group__PkgBGLHelperFct.html#gad93e429ad24efeaddeb836c437e719ab">is_border</a>(h, mesh1) )</div>
<div class="line">        {</div>
<div class="line">          face_descriptor f=face(h, mesh1);</div>
<div class="line">          <span class="keywordflow">if</span> ( !is_selected[f] )</div>
<div class="line">          {</div>
<div class="line">            selected_faces.push_back(f);</div>
<div class="line">            is_selected[f]=<span class="keyword">true</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// increase the face selection</span></div>
<div class="line">  <a class="codeRef" href="../BGL/group__PkgBGLSelectionFct.html#ga569fe26f889e5e4eed27746ac921651b">CGAL::expand_face_selection</a>(selected_faces, mesh1, 2,</div>
<div class="line">    Vector_pmap_wrapper(is_selected), std::back_inserter(selected_faces));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; selected_faces.size()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; faces were selected for the remeshing step\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// remesh the region around the intersection polylines</span></div>
<div class="line">  <a class="code" href="group__PMP__meshing__grp.html#gad3d03890515ae8103bd32a30a3486412">PMP::isotropic_remeshing</a>(</div>
<div class="line">    selected_faces,</div>
<div class="line">    0.02,</div>
<div class="line">    mesh1,</div>
<div class="line">    params::edge_is_constrained_map(is_constrained_map) );</div>
<div class="line"> </div>
<div class="line">  std::ofstream output(<span class="stringliteral">&quot;difference_remeshed.off&quot;</span>);</div>
<div class="line">  output.precision(17);</div>
<div class="line">  output &lt;&lt; mesh1;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="coref_ex_consq_subsec"></a>
Robustness of Consecutive Operations</h3>
<p>This example computes the intersection of two volumes and then does the union of the result with one of the input volumes. This operation is in general not possible when using inexact constructions. Instead of using a mesh with a point from a kernel with exact constructions, the exact points are a property of the mesh vertices that we can reuse in a later operations. With that property, we can manipulate a mesh with points having floating point coordinates but benefit from the robustness provided by the exact constructions. <br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2corefinement_consecutive_bool_op_8cpp-example.html">Polygon_mesh_processing/corefinement_consecutive_bool_op.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/corefinement.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> EK;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a> Mesh;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor vertex_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> Mesh::Property_map&lt;vertex_descriptor,EK::Point_3&gt; Exact_point_map;</div>
<div class="line"><span class="keyword">typedef</span> Mesh::Property_map&lt;vertex_descriptor,bool&gt; Exact_point_computed;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"><span class="keyword">namespace </span>params = PMP::parameters;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Coref_point_map</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// typedef for the property map</span></div>
<div class="line">  <span class="keyword">typedef</span> boost::property_traits&lt;Exact_point_map&gt;::value_type value_type;</div>
<div class="line">  <span class="keyword">typedef</span> boost::property_traits&lt;Exact_point_map&gt;::reference reference;</div>
<div class="line">  <span class="keyword">typedef</span> boost::property_traits&lt;Exact_point_map&gt;::category category;</div>
<div class="line">  <span class="keyword">typedef</span> boost::property_traits&lt;Exact_point_map&gt;::key_type key_type;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// exterior references</span></div>
<div class="line">  Exact_point_computed* exact_point_computed_ptr;</div>
<div class="line">  Exact_point_map* exact_point_ptr;</div>
<div class="line">  Mesh* mesh_ptr;</div>
<div class="line"> </div>
<div class="line">  Exact_point_computed&amp; exact_point_computed()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    CGAL_assertion(exact_point_computed_ptr!=NULL);</div>
<div class="line">    <span class="keywordflow">return</span> *exact_point_computed_ptr;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  Exact_point_map&amp; exact_point()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    CGAL_assertion(exact_point_ptr!=NULL);</div>
<div class="line">    <span class="keywordflow">return</span> *exact_point_ptr;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  Mesh&amp; mesh()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    CGAL_assertion(mesh_ptr!=NULL);</div>
<div class="line">    <span class="keywordflow">return</span> *mesh_ptr;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Converters</span></div>
<div class="line">  <a class="codeRef" href="../Kernel_23/classCGAL_1_1Cartesian__converter.html">CGAL::Cartesian_converter&lt;K, EK&gt;</a> to_exact;</div>
<div class="line">  <a class="codeRef" href="../Kernel_23/classCGAL_1_1Cartesian__converter.html">CGAL::Cartesian_converter&lt;EK, K&gt;</a> to_input;</div>
<div class="line"> </div>
<div class="line">  Coref_point_map()</div>
<div class="line">    : exact_point_computed_ptr(NULL)</div>
<div class="line">    , exact_point_ptr(NULL)</div>
<div class="line">    , mesh_ptr(NULL)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  Coref_point_map(Exact_point_map&amp; ep,</div>
<div class="line">                  Exact_point_computed&amp; epc,</div>
<div class="line">                  Mesh&amp; m)</div>
<div class="line">    : exact_point_computed_ptr(&amp;epc)</div>
<div class="line">    , exact_point_ptr(&amp;ep)</div>
<div class="line">    , mesh_ptr(&amp;m)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">friend</span></div>
<div class="line">  reference get(<span class="keyword">const</span> Coref_point_map&amp; map, key_type k)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// create exact point if it does not exist</span></div>
<div class="line">    <span class="keywordflow">if</span> (!map.exact_point_computed()[k]){</div>
<div class="line">      map.exact_point()[k]=map.to_exact(map.mesh().point(k));</div>
<div class="line">      map.exact_point_computed()[k]=<span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> map.exact_point()[k];</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">friend</span></div>
<div class="line">  <span class="keywordtype">void</span> put(<span class="keyword">const</span> Coref_point_map&amp; map, key_type k, <span class="keyword">const</span> EK::Point_3&amp; p)</div>
<div class="line">  {</div>
<div class="line">    map.exact_point_computed()[k]=<span class="keyword">true</span>;</div>
<div class="line">    map.exact_point()[k]=p;</div>
<div class="line">    <span class="comment">// create the input point from the exact one</span></div>
<div class="line">    map.mesh().point(k)=map.to_input(p);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename1 = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/blobby.off&quot;</span>;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename2 = (argc &gt; 2) ? argv[2] : <span class="stringliteral">&quot;data/eight.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename1);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh1, mesh2;</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh1))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;First mesh is not a valid off file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line">  input.close();</div>
<div class="line">  input.open(filename2);</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh2))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Second mesh is not a valid off file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  Exact_point_map mesh1_exact_points =</div>
<div class="line">    mesh1.add_property_map&lt;vertex_descriptor,EK::Point_3&gt;(<span class="stringliteral">&quot;e:exact_point&quot;</span>).first;</div>
<div class="line">  Exact_point_computed mesh1_exact_points_computed =</div>
<div class="line">    mesh1.add_property_map&lt;vertex_descriptor,<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;e:exact_points_computed&quot;</span>).first;</div>
<div class="line"> </div>
<div class="line">  Exact_point_map mesh2_exact_points =</div>
<div class="line">    mesh2.add_property_map&lt;vertex_descriptor,EK::Point_3&gt;(<span class="stringliteral">&quot;e:exact_point&quot;</span>).first;</div>
<div class="line">  Exact_point_computed mesh2_exact_points_computed =</div>
<div class="line">    mesh2.add_property_map&lt;vertex_descriptor,<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;e:exact_points_computed&quot;</span>).first;</div>
<div class="line"> </div>
<div class="line">  Coref_point_map mesh1_pm(mesh1_exact_points, mesh1_exact_points_computed, mesh1);</div>
<div class="line">  Coref_point_map mesh2_pm(mesh2_exact_points, mesh2_exact_points_computed, mesh2);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> ( <a class="code" href="group__PMP__corefinement__grp.html#ga240e5df984c7d44741a7031e38203dc3">PMP::corefine_and_compute_intersection</a>(mesh1,</div>
<div class="line">                                              mesh2,</div>
<div class="line">                                              mesh1,</div>
<div class="line">                                              params::vertex_point_map(mesh1_pm),</div>
<div class="line">                                              params::vertex_point_map(mesh2_pm),</div>
<div class="line">                                              params::vertex_point_map(mesh1_pm) ) )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> ( <a class="code" href="group__PMP__corefinement__grp.html#gad7e1741a7ce41a5846cf86494982ca8b">PMP::corefine_and_compute_union</a>(mesh1,</div>
<div class="line">                                         mesh2,</div>
<div class="line">                                         mesh2,</div>
<div class="line">                                         params::vertex_point_map(mesh1_pm),</div>
<div class="line">                                         params::vertex_point_map(mesh2_pm),</div>
<div class="line">                                         params::vertex_point_map(mesh2_pm) ) )</div>
<div class="line">    {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Intersection and union were successfully computed\n&quot;</span>;</div>
<div class="line">      std::ofstream output(<span class="stringliteral">&quot;inter_union.off&quot;</span>);</div>
<div class="line">      output.precision(17);</div>
<div class="line">      output &lt;&lt; mesh2;</div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Union could not be computed\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Intersection could not be computed\n&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="PMPHoleFilling"></a>
Hole Filling</h1>
<p>This package provides an algorithm for filling one closed hole that is either in a triangulated surface mesh or defined by a sequence of points that describe a polyline. The main steps of the algorithm are described in <a class="el" href="citelist.html#CITEREF_liepa2003filling">[9]</a> and can be summarized as follows.</p>
<p>First, the largest patch triangulating the boundary of the hole is generated without introducing any new vertex. The patch is selected so as to minimize a quality function evaluated for all possible triangular patches. The quality function first minimizes the worst dihedral angle between patch triangles, then the total surface area of the patch as a tiebreaker. Following the suggestions in <a class="el" href="citelist.html#CITEREF_zou2013algorithm">[12]</a>, the performance of the algorithm is significantly improved by narrowing the search space to faces of a 3D Delaunay triangulation of the hole boundary vertices, from all possible patches, while searching for the best patch with respect to the aforementioned quality criteria.</p>
<p>For some complicated input hole boundary, the generated patch may have self-intersections. After hole filling, the generated patch can be refined and faired using the meshing functions <code><a class="el" href="group__PMP__meshing__grp.html#gad0449d8e1021fc46507074cd6db65ef4" title="refines a region of a triangle mesh">CGAL::Polygon_mesh_processing::refine()</a></code> and <code><a class="el" href="group__PMP__meshing__grp.html#gaa091c8368920920eed87784107d68ecf" title="fairs a region on a triangle mesh. The points of the selected vertices are relocated to yield an as-s...">CGAL::Polygon_mesh_processing::fair()</a></code> described in Section <a class="el" href="index.html#PMPMeshing">Meshing</a>.</p>
<p><a class="anchor" id="fig__Mech_steps"></a></p><div class="image">
<img src="mech_hole_horz.jpg" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__Mech_steps">fig__Mech_steps</a> Results of the main steps of the algorithm. From left to right: (a) the hole, (b) the hole after its triangulation, (c) after triangulation and refinement, (d) after triangulation, refinement and fairing. </p> </div> <p> <br  />
</p>
<h2><a class="anchor" id="HoleFillingAPI"></a>
API</h2>
<p>This package provides four functions for hole filling:</p><ul>
<li><code><a class="el" href="group__hole__filling__grp.html#ga8508fd49a2482ec7dcb3e1799234696a">triangulate_hole_polyline()</a></code> : given a sequence of points defining the hole, triangulates the hole.</li>
<li><code><a class="el" href="group__hole__filling__grp.html#ga4aacaa46c800a53ca0a0e5fd518a7b20">triangulate_hole()</a></code> : given a border halfedge on the boundary of the hole on a mesh, triangulates the hole.</li>
<li><code><a class="el" href="group__hole__filling__grp.html#gaaa1bfaf9a57dea8b6c71168a18f9b6eb" title="triangulates and refines a hole in a polygon mesh.">triangulate_and_refine_hole()</a></code> : in addition to <code><a class="el" href="group__hole__filling__grp.html#ga4aacaa46c800a53ca0a0e5fd518a7b20">triangulate_hole()</a></code> the generated patch is refined.</li>
<li><code><a class="el" href="group__hole__filling__grp.html#ga19bc0ac51dc9a1ee78c3e7a0d57de47d" title="triangulates, refines and fairs a hole in a polygon mesh.">triangulate_refine_and_fair_hole()</a></code> : in addition to <code><a class="el" href="group__hole__filling__grp.html#gaaa1bfaf9a57dea8b6c71168a18f9b6eb" title="triangulates and refines a hole in a polygon mesh.">triangulate_and_refine_hole()</a></code> the generated patch is also faired.</li>
</ul>
<h2><a class="anchor" id="HFExamples"></a>
Examples</h2>
<h3><a class="anchor" id="HFExample_1"></a>
Triangulate a Polyline</h3>
<p>The following example triangulates a hole described by an input polyline.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2triangulate_polyline_example_8cpp-example.html">Polygon_mesh_processing/triangulate_polyline_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_hole.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/utility.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="codeRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;Point&gt; polyline;</div>
<div class="line">  polyline.push_back(Point( 1.,0.,0.));</div>
<div class="line">  polyline.push_back(Point( 0.,1.,0.));</div>
<div class="line">  polyline.push_back(Point(-1.,0.,0.));</div>
<div class="line">  polyline.push_back(Point( 1.,1.,0.));</div>
<div class="line">  <span class="comment">// repeating first point (i.e. polyline.push_back(Point(1.,0.,0.)) ) is optional</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// any type, having Type(int, int, int) constructor available, can be used to hold output triangles</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="codeRef" href="../STL_Extension/classCGAL_1_1Triple.html">CGAL::Triple&lt;int, int, int&gt;</a> Triangle_int;</div>
<div class="line">  std::vector&lt;Triangle_int&gt; patch;</div>
<div class="line">  patch.reserve(polyline.size() -2); <span class="comment">// there will be exactly n-2 triangles in the patch</span></div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__hole__filling__grp.html#ga8508fd49a2482ec7dcb3e1799234696a">CGAL::Polygon_mesh_processing::triangulate_hole_polyline</a>(</div>
<div class="line">          polyline,</div>
<div class="line">          std::back_inserter(patch));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; patch.size(); ++i)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Triangle &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div>
<div class="line">      &lt;&lt; patch[i].first &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; patch[i].second &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; patch[i].third</div>
<div class="line">      &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// note that no degenerate triangles are generated in the patch</span></div>
<div class="line">  std::vector&lt;Point&gt; polyline_collinear;</div>
<div class="line">  polyline_collinear.push_back(Point(1.,0.,0.));</div>
<div class="line">  polyline_collinear.push_back(Point(2.,0.,0.));</div>
<div class="line">  polyline_collinear.push_back(Point(3.,0.,0.));</div>
<div class="line">  polyline_collinear.push_back(Point(4.,0.,0.));</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Triangle_int&gt; patch_will_be_empty;</div>
<div class="line">  <a class="code" href="group__hole__filling__grp.html#ga8508fd49a2482ec7dcb3e1799234696a">CGAL::Polygon_mesh_processing::triangulate_hole_polyline</a>(</div>
<div class="line">          polyline_collinear,</div>
<div class="line">          back_inserter(patch_will_be_empty));</div>
<div class="line">  CGAL_assertion(patch_will_be_empty.empty());</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="HFExample_2"></a>
Hole Filling From the Border of the Hole</h3>
<p>If the input polygon mesh has a hole or more than one hole, it is possible to iteratively fill them by detecting border edges (i.e. with only one incident non-null face) after each hole filling step.</p>
<p>Holes are filled one after the other, and the process stops when there is no border edge left.</p>
<p>This process is illustrated by the example below, where holes are iteratively filled, refined and faired. Optionally, only holes not exceeding a certain diameter or number of edges can be filled. This example assumes that the mesh is stored in a <code><a class="elRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> datastructure. Analogous examples when using the <code><a class="elRef" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> class and a few others are part of the code base.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2hole_filling_example_SM_8cpp-example.html">Polygon_mesh_processing/hole_filling_example_SM.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_hole.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/border.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;set&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="codeRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a> Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::halfedge_descriptor   halfedge_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor       face_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor     vertex_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> is_small_hole(halfedge_descriptor h, Mesh &amp; mesh,</div>
<div class="line">                   <span class="keywordtype">double</span> max_hole_diam, <span class="keywordtype">int</span> max_num_hole_edges)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> num_hole_edges = 0;</div>
<div class="line">  <a class="codeRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> hole_bbox;</div>
<div class="line">  <span class="keywordflow">for</span> (halfedge_descriptor hc : <a class="codeRef" href="../BGL/group__PkgBGLIterators.html#ga37229df31508a78eb4acdaf907e637e5">CGAL::halfedges_around_face</a>(h, mesh))</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> Point&amp; p = mesh.point(target(hc, mesh));</div>
<div class="line"> </div>
<div class="line">    hole_bbox += p.bbox();</div>
<div class="line">    ++num_hole_edges;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Exit early, to avoid unnecessary traversal of large holes</span></div>
<div class="line">    <span class="keywordflow">if</span> (num_hole_edges &gt; max_num_hole_edges) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (hole_bbox.<a class="codeRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>() - hole_bbox.<a class="codeRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>() &gt; max_hole_diam) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (hole_bbox.<a class="codeRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>() - hole_bbox.<a class="codeRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>() &gt; max_hole_diam) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (hole_bbox.<a class="codeRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>() - hole_bbox.<a class="codeRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>() &gt; max_hole_diam) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Incrementally fill the holes that are no larger than given diameter</span></div>
<div class="line"><span class="comment">// and with no more than a given number of edges (if specified).</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/mech-holes-shark.off&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Both of these must be positive in order to be considered</span></div>
<div class="line">  <span class="keywordtype">double</span> max_hole_diam   = (argc &gt; 2) ? boost::lexical_cast&lt;double&gt;(argv[2]): -1.0;</div>
<div class="line">  <span class="keywordtype">int</span> max_num_hole_edges = (argc &gt; 3) ? boost::lexical_cast&lt;int&gt;(argv[3]) : -1;</div>
<div class="line"> </div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span> ( !input || !(input &gt;&gt; mesh) ) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Not a valid off file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_holes = 0;</div>
<div class="line">  std::vector&lt;halfedge_descriptor&gt; border_cycles;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// collect one halfedge per boundary cycle</span></div>
<div class="line">  <a class="code" href="group__PkgPolygonMeshProcessingRef.html#gafa9b682528c5dc2a4821d01193518d14">CGAL::Polygon_mesh_processing::extract_boundary_cycles</a>(mesh, std::back_inserter(border_cycles));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(halfedge_descriptor h : border_cycles)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(max_hole_diam &gt; 0 &amp;&amp; max_num_hole_edges &gt; 0 &amp;&amp;</div>
<div class="line">       !is_small_hole(h, mesh, max_hole_diam, max_num_hole_edges))</div>
<div class="line">      <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;face_descriptor&gt;  patch_facets;</div>
<div class="line">    std::vector&lt;vertex_descriptor&gt; patch_vertices;</div>
<div class="line">    <span class="keywordtype">bool</span> success = std::get&lt;0&gt;(</div>
<div class="line">      <a class="code" href="group__hole__filling__grp.html#ga19bc0ac51dc9a1ee78c3e7a0d57de47d">CGAL::Polygon_mesh_processing::triangulate_refine_and_fair_hole</a>(</div>
<div class="line">                mesh,</div>
<div class="line">                h,</div>
<div class="line">                std::back_inserter(patch_facets),</div>
<div class="line">                std::back_inserter(patch_vertices)) );</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;* Number of facets in constructed patch: &quot;</span> &lt;&lt; patch_facets.size() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of vertices in constructed patch: &quot;</span> &lt;&lt; patch_vertices.size() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Is fairing successful: &quot;</span> &lt;&lt; success &lt;&lt; std::endl;</div>
<div class="line">    ++nb_holes;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; nb_holes &lt;&lt; <span class="stringliteral">&quot; holes have been filled&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::string outfile = <span class="stringliteral">&quot;filled_SM.off&quot;</span>;</div>
<div class="line">  std::ofstream out(outfile.c_str());</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh written to: &quot;</span> &lt;&lt; outfile &lt;&lt; std::endl;</div>
<div class="line">  out.precision(17);</div>
<div class="line">  out &lt;&lt; mesh &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="fig__Triangulated_fork"></a></p><div class="image">
<img src="fork.jpg" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__Triangulated_fork">fig__Triangulated_fork</a> Holes in the fork model are filled with triangle patches. </p> </div> <p> <br  />
</p>
<h2><a class="anchor" id="HFPerformance"></a>
Performance</h2>
<p>The hole filling algorithm has a complexity which depends on the number of vertices. While <a class="el" href="citelist.html#CITEREF_liepa2003filling">[9]</a> has a running time of \( O(n^3)\) , <a class="el" href="citelist.html#CITEREF_zou2013algorithm">[12]</a> in most cases has running time of \( O(n \log n)\). We benchmarked the function <code><a class="el" href="group__hole__filling__grp.html#ga19bc0ac51dc9a1ee78c3e7a0d57de47d" title="triangulates, refines and fairs a hole in a polygon mesh.">triangulate_refine_and_fair_hole()</a></code> for the two meshes below (as well as two more meshes with smaller holes). The machine used was a PC running Windows 10 with an Intel Core i7 CPU clocked at 2.70 GHz. The program was compiled with the Visual C++ 2013 compiler with the O2 option, which maximizes speed.</p>
<p><a class="anchor" id="fig__Elephants"></a></p><div class="image">
<img src="elephants-with-holes.png" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__Elephants">fig__Elephants</a> The elephant on the left/right has a hole with 963/7657 vertices. </p> </div> <p> <br  />
</p>
<p>The following running times were observed:</p>
<center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight"># vertices </th><th class="markdownTableHeadRight">without Delaunay (sec.) </th><th class="markdownTableHeadRight">with Delaunay (sec.)  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">565 </td><td class="markdownTableBodyRight">8.5 </td><td class="markdownTableBodyRight">0.03  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">774 </td><td class="markdownTableBodyRight">21 </td><td class="markdownTableBodyRight">0.035  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">967 </td><td class="markdownTableBodyRight">43 </td><td class="markdownTableBodyRight">0.06  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">7657 </td><td class="markdownTableBodyRight">na </td><td class="markdownTableBodyRight">0.4  </td></tr>
</table>
</center><h1><a class="anchor" id="PMPPredicates"></a>
Predicates</h1>
<p>This packages provides several predicates to be evaluated with respect to a triangle mesh.</p>
<h2><a class="anchor" id="PMPDoIntersect"></a>
Intersections Detection</h2>
<p>Intersection tests between triangle meshes and/or polylines can be done using <a class="el" href="group__PMP__predicates__grp.html"><code>CGAL::Polygon_mesh_processing::do_intersect()</code> </a>. Additionally, the function <code><a class="el" href="group__PMP__predicates__grp.html#ga1ff63ec6e762d45ea5775bf7b49f9270">CGAL::Polygon_mesh_processing::intersecting_meshes()</a></code> records all pairs of intersecting meshes in a range.</p>
<h3><a class="anchor" id="PMPSelIntersections"></a>
Self Intersections</h3>
<p>Self intersections within a triangle mesh can be detected by calling the function <code><a class="el" href="group__PMP__intersection__grp.html#gad9fe5d8b433545b69154f43935a11a3b">CGAL::Polygon_mesh_processing::does_self_intersect()</a></code>. Additionally, the function <code><a class="el" href="group__PMP__intersection__grp.html#gaf19c80ec12cbff7ebe9e69453f1d40b8">CGAL::Polygon_mesh_processing::self_intersections()</a></code> reports all pairs of intersecting triangles.</p>
<h3><a class="anchor" id="SIExample"></a>
Self Intersections Example</h3>
<p>The following example illustrates the detection of self intersection in the <code>pig.off</code> mesh. The detected self-intersection is illustrated on Figure <a class="el" href="index.html#fig__SelfIntersections">fig__SelfIntersections</a>.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2self_intersections_example_8cpp-example.html">Polygon_mesh_processing/self_intersections_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/self_intersections.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/tags.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                      Mesh;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor          face_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/pig.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh) || !<a class="codeRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Not a valid input file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Using parallel mode? &quot;</span> &lt;&lt; std::is_same&lt;CGAL::Parallel_if_available_tag, CGAL::Parallel_tag&gt;::value &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  CGAL::Real_timer timer;</div>
<div class="line">  timer.start();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> intersecting = PMP::does_self_intersect&lt;CGAL::Parallel_if_available_tag&gt;(mesh, CGAL::parameters::vertex_point_map(get(CGAL::vertex_point, mesh)));</div>
<div class="line">  std::cout &lt;&lt; (intersecting ? <span class="stringliteral">&quot;There are self-intersections.&quot;</span> : <span class="stringliteral">&quot;There is no self-intersection.&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Elapsed time (does self intersect): &quot;</span> &lt;&lt; timer.time() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  timer.reset();</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;std::pair&lt;face_descriptor, face_descriptor&gt; &gt; intersected_tris;</div>
<div class="line">  PMP::self_intersections&lt;CGAL::Parallel_if_available_tag&gt;(faces(mesh), mesh, std::back_inserter(intersected_tris));</div>
<div class="line">  std::cout &lt;&lt; intersected_tris.size() &lt;&lt; <span class="stringliteral">&quot; pairs of triangles intersect.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Elapsed time (self intersections): &quot;</span> &lt;&lt; timer.time() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="fig__SelfIntersections"></a></p><center> <img src="selfintersections.jpg" alt="" style="max-width:70%;" class="inline"/> </center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__SelfIntersections">fig__SelfIntersections</a> Detecting self-intersections on a triangle mesh. The intersecting triangles are displayed in dark grey and red on the right image. </p> </div> <p> <br  />
</p>
<h2><a class="anchor" id="PMPInsideTest"></a>
Side of Triangle Mesh</h2>
<p>The class <code><a class="el" href="classCGAL_1_1Side__of__triangle__mesh.html">CGAL::Side_of_triangle_mesh</a></code> provides a functor that tests whether a query point is inside, outside, or on the boundary of the domain bounded by a given closed triangle mesh.</p>
<p>A point is said to be on the bounded side of the domain bounded by the input triangle mesh if an odd number of surfaces is crossed when walking from the point to infinity. The input triangle mesh is expected to contain no self-intersections and to be free from self-inclusions.</p>
<p>The algorithm can handle the case of a triangle mesh with several connected components, and returns correct results. In case of self-inclusions, the ray intersections parity test is performed, and the execution will not fail. However, the user should be aware that the predicate alternately considers sub-volumes to be on the bounded and unbounded sides of the input triangle mesh.</p>
<h3><a class="anchor" id="InsideExample"></a>
Inside Test Example</h3>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2point_inside_example_8cpp-example.html">Polygon_mesh_processing/point_inside_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Side_of_triangle_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> K::Point_3 Point;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;K&gt;</a> Polyhedron;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> max_coordinate(<span class="keyword">const</span> Polyhedron&amp; poly)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">double</span> max_coord = -std::numeric_limits&lt;double&gt;::infinity();</div>
<div class="line">  <span class="keywordflow">for</span>(Polyhedron::Vertex_handle v : vertices(poly))</div>
<div class="line">  {</div>
<div class="line">    Point p = v-&gt;point();</div>
<div class="line">    max_coord = (std::max)(max_coord, p.x());</div>
<div class="line">    max_coord = (std::max)(max_coord, p.y());</div>
<div class="line">    max_coord = (std::max)(max_coord, p.z());</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> max_coord;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/eight.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line"> </div>
<div class="line">  Polyhedron poly;</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; poly) || poly.empty()</div>
<div class="line">             || !<a class="codeRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(poly))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Not a valid input file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classCGAL_1_1Side__of__triangle__mesh.html">CGAL::Side_of_triangle_mesh&lt;Polyhedron, K&gt;</a> inside(poly);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> size = max_coordinate(poly);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_points = 100;</div>
<div class="line">  std::vector&lt;Point&gt; points;</div>
<div class="line">  points.reserve(nb_points);</div>
<div class="line">  <a class="codeRef" href="../Generator/classCGAL_1_1Random__points__in__cube__3.html">CGAL::Random_points_in_cube_3&lt;Point&gt;</a> gen(size);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nb_points; ++i)</div>
<div class="line">    points.push_back(*gen++);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Test &quot;</span> &lt;&lt; nb_points &lt;&lt; <span class="stringliteral">&quot; random points in cube &quot;</span></div>
<div class="line">    &lt;&lt; <span class="stringliteral">&quot;[-&quot;</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">&quot;; &quot;</span> &lt;&lt; size &lt;&lt;<span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> nb_inside = 0;</div>
<div class="line">  <span class="keywordtype">int</span> nb_boundary = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; nb_points; ++i)</div>
<div class="line">  {</div>
<div class="line">    <a class="codeRef" href="../Kernel_23/group__kernel__enums.html#gaf6030e89dadcc1f45369b0cdc5d9e111">CGAL::Bounded_side</a> res = inside(points[i]);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (res == <a class="codeRef" href="../Kernel_23/group__kernel__enums.html#ggaf6030e89dadcc1f45369b0cdc5d9e111ad8333d35d4801c08b3a5ae9e94d7cabe">CGAL::ON_BOUNDED_SIDE</a>) { ++nb_inside; }</div>
<div class="line">    <span class="keywordflow">if</span> (res == <a class="codeRef" href="../Kernel_23/group__kernel__enums.html#ggaf6030e89dadcc1f45369b0cdc5d9e111a060193157c0875fb2e6445a648f3ac1f">CGAL::ON_BOUNDARY</a>) { ++nb_boundary; }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;Total query size: &quot;</span> &lt;&lt; points.size() &lt;&lt; std::endl;</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; nb_inside &lt;&lt; <span class="stringliteral">&quot; points inside &quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; nb_boundary &lt;&lt; <span class="stringliteral">&quot; points on boundary &quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; points.size() - nb_inside - nb_boundary &lt;&lt; <span class="stringliteral">&quot; points outside &quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="PMPShapePredicates"></a>
Shape Predicates</h2>
<p>Badly shaped or, even worse, completely degenerate elements of a polygon mesh are problematic in many algorithms which one might want to use on the mesh. This package offers a toolkit of functions to detect such undesirable elements.</p><ul>
<li><code><a class="el" href="group__PMP__repairing__grp.html#ga01a4a699d8e5d0193d4823297eddbeec">CGAL::Polygon_mesh_processing::is_degenerate_edge()</a></code>, to detect if an edge is degenerate (that is, if its two vertices share the same geometric location).</li>
<li><code><a class="el" href="group__PMP__repairing__grp.html#ga3722f80ee24b4a245e68e0543d728962">CGAL::Polygon_mesh_processing::is_degenerate_triangle_face()</a></code>, to detect if a face is degenerate (that is, if its three vertices are collinear).</li>
<li><code><a class="el" href="group__PMP__repairing__grp.html#ga12b3f7ea338a8c85c6e76e45b5cecb65">CGAL::Polygon_mesh_processing::degenerate_edges()</a></code>, to collect degenerate edges within a range of edges.</li>
<li><code><a class="el" href="group__PMP__repairing__grp.html#gac52914e9cef997019e208ede623b59bd">CGAL::Polygon_mesh_processing::degenerate_faces()</a></code>, to collect degenerate faces within a range of faces.</li>
<li><code><a class="el" href="group__PMP__repairing__grp.html#gaca492be12487dcc62596b5b67a421f60">CGAL::Polygon_mesh_processing::is_cap_triangle_face()</a></code></li>
<li><code><a class="el" href="group__PMP__repairing__grp.html#ga5804fdd0baa6c9b44e7c31a743a0974a">CGAL::Polygon_mesh_processing::is_needle_triangle_face()</a></code></li>
</ul>
<h2><a class="anchor" id="PMPLocationFunctions"></a>
Surface Location Functions</h2>
<p>To ease the manipulation of points on a surface, <span style="font-variant: small-caps;">CGAL</span> offers a multitude of functions based upon a different representation of a point on a polygon mesh: the point is represented as a pair of a face of the polygon mesh and a triplet of barycentric coordinates. This definition enables a robust handling of polylines between points living in the same face: for example, two 3D segments created by four points within the same face that should intersect might not actually intersect due to inexact computations. However, manipulating these same points through their barycentric coordinates can instead be done, and intersections computed in the barycentric space will not suffer from the same issues. Furthermore, this definition is only dependent on the intrinsic dimension of the surface (i.e. 2) and not on the ambient dimension within which the surface is embedded.</p>
<p>The functions of the group <a class="el" href="group__PMP__locate__grp.html">Location Functions</a> offer the following functionalities: location computations (<code><a class="el" href="group__PMP__locate__grp.html#ga31ac15330b5a5aef19bd22770f3c7560" title="returns the nearest face location to the given point.">CGAL::Polygon_mesh_processing::locate()</a></code>, and similar) given a point, finding the nearest point on a mesh given a point or a ray (<code><a class="el" href="group__PMP__locate__grp.html#ga92106c8af15fab1d186c5a33e6318b8a" title="returns the face location nearest to the given point, as a location.">CGAL::Polygon_mesh_processing::locate_with_AABB_tree()</a></code>, and similar), and location-based predicates (for example, <code><a class="el" href="group__PMP__locate__grp.html#ga455a6b4f1edfd88358a1150c870691e9" title="Given a location, returns whether the location is on the boundary of the face or not.">CGAL::Polygon_mesh_processing::is_on_face_border()</a></code>).</p>
<p>The example <a class="el" href="Polygon_mesh_processing_2locate_example_8cpp-example.html">Polygon_mesh_processing/locate_example.cpp</a> presents a few of these functions.</p>
<h1><a class="anchor" id="PMPOrientation"></a>
Orientation</h1>
<p>This package offers multiple functions to compute consistent face orientations for set of faces (Section <a class="el" href="index.html#PolygonSoups">Polygon Soups</a>) and polygon meshes (Section <a class="el" href="index.html#OrientingPolygonMeshes">Polygon Meshes</a>). Section <a class="el" href="index.html#PolygonSoupExample">Orientation Examples</a> offers an example of combination of these functions.</p>
<h2><a class="anchor" id="PolygonSoups"></a>
Polygon Soups</h2>
<p>When the faces of a polygon mesh are given but the connectivity is unknown, this set of faces is called a <em>polygon</em> <em>soup</em>.</p>
<p>Before running any of the algorithms on a polygon soup, one should ensure that the polygons are consistently oriented. To do so, this package provides the function <code><a class="el" href="group__PMP__orientation__grp.html#gaadc5bac3072b11d2313e40043c729d0a">CGAL::Polygon_mesh_processing::orient_polygon_soup()</a></code>, described in <a class="el" href="citelist.html#CITEREF_gueziec2001cutting">[1]</a>.</p>
<p>To deal with polygon soups that cannot be converted to a combinatorially manifold surface, some points must be duplicated. Because a polygon soup does not have any connectivity (each point has as many occurrences as the number of polygons it belongs to), duplicating one point (or a pair of points) amounts to duplicating the polygon to which it belongs. The duplicated points are either an endpoint of an edge incident to more than two polygons, an endpoint of an edge between two polygons with incompatible orientations (during the re-orientation process), or more generally a point <em>p</em> at which the intersection of an infinitesimally small ball centered at <em>p</em> with the polygons incident to it is not a topological disk.</p>
<p>Once the polygon soup is consistently oriented, with possibly duplicated (or more) points, the connectivity can be recovered and made consistent to build a valid polygon mesh. The function <code><a class="el" href="group__PMP__repairing__grp.html#ga0dec58e8a0112791f72ebbe77bac074b">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh()</a></code> performs this mesh construction step.</p>
<p>Inversely, a polygon soup can be constructed from a polygon mesh, using the function <code><a class="el" href="group__PMP__repairing__grp.html#ga76648a509409ff3c3ad3f71eff8ce9d9">CGAL::Polygon_mesh_processing::polygon_mesh_to_polygon_soup()</a></code>.</p>
<h2><a class="anchor" id="OrientingPolygonMeshes"></a>
Polygon Meshes</h2>
<p>This package provides functions dealing with the orientation of faces in a closed polygon mesh.</p>
<ul>
<li>The function <code><a class="el" href="group__PMP__orientation__grp.html#gafe035adcc4ff061b4438cc9dae591d00">CGAL::Polygon_mesh_processing::orient()</a></code> makes each connected component of a closed polygon mesh outward- or inward-oriented.</li>
<li>The function <code><a class="el" href="group__PMP__orientation__grp.html#gafdbc256d06536f6aca2558bc1a0156e2">CGAL::Polygon_mesh_processing::orient_to_bound_a_volume()</a></code> orients the connected components of a closed polygon mesh so that it bounds a volume (see <a class="el" href="index.html#coref_def_subsec">Definitions</a> for the precise definition).</li>
<li>The function <code><a class="el" href="group__PMP__orientation__grp.html#ga53a77073bf9a4118ecf949b851e1f5d9">CGAL::Polygon_mesh_processing::is_outward_oriented()</a></code> checks whether an oriented polygon mesh is oriented such that the normals to all faces are oriented towards the outside of the domain bounded by the input polygon mesh.</li>
<li>The function <code><a class="el" href="group__PMP__orientation__grp.html#gad8a3439883e3e76651f96d15ba58b2bc">CGAL::Polygon_mesh_processing::reverse_face_orientations()</a></code> reverses the orientation of halfedges around faces. As a consequence, the normal computed for each face (see Section <a class="el" href="index.html#PMPNormalComp">Computing Normals</a>) is also reversed.</li>
<li>The function <code><a class="el" href="group__PMP__orientation__grp.html#ga133e58280959c152770525f27bb42b91">CGAL::Polygon_mesh_processing::volume_connected_components()</a></code> provides information about the 3D arrangement of the surface connected components in a given triangle mesh. It comes with many named parameter options making it also a more general version of <code><a class="el" href="group__PMP__orientation__grp.html#ga53a77073bf9a4118ecf949b851e1f5d9">is_outward_oriented()</a></code>.</li>
<li>The function <code><a class="el" href="group__PMP__orientation__grp.html#ga2aa4f7b500dc51d1fc4747705a050946">CGAL::Polygon_mesh_processing::duplicate_non_manifold_edges_in_polygon_soup()</a></code> duplicates points and edges to make a soup orientable, without changing the orientation of the faces.</li>
<li>The function <code><a class="el" href="group__PMP__orientation__grp.html#ga31779672b3afd660664fc9a6c4fdf74d">CGAL::Polygon_mesh_processing::orient_triangle_soup_with_reference_triangle_mesh()</a></code> takes an input mesh as a reference and orients the triangles of a soup according to it.</li>
<li>The function <code><a class="el" href="group__PMP__orientation__grp.html#gae25c1198a89c53d5df2f29dd57fda5ca">CGAL::Polygon_mesh_processing::merge_reversible_connected_components()</a></code> merges the connected components of a polygon mesh if possible. </li>
</ul>
<h2><a class="anchor" id="PolygonSoupExample"></a>
Orientation Examples</h2>
<p>This example shows how to generate a mesh from a polygon soup. The first step is to get a soup of consistently oriented faces, before rebuilding the connectivity. In this example, some orientation tests are performed on the output polygon mesh to illustrate Section <a class="el" href="index.html#PMPOrientation">Orientation</a>.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2orient_polygon_soup_example_8cpp-example.html">Polygon_mesh_processing/orient_polygon_soup_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_items_with_id_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/orient_polygon_soup.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/orientation.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/IO/OFF_reader.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>          K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;K, CGAL::Polyhedron_items_with_id_3&gt;</a>      Polyhedron;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/tet-shuffled.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;K::Point_3&gt; points;</div>
<div class="line">  std::vector&lt;std::vector&lt;std::size_t&gt; &gt; polygons;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>(!input || !CGAL::read_OFF(input, points, polygons) || points.empty())</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Cannot open file &quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__PMP__orientation__grp.html#gaadc5bac3072b11d2313e40043c729d0a">CGAL::Polygon_mesh_processing::orient_polygon_soup</a>(points, polygons);</div>
<div class="line"> </div>
<div class="line">  Polyhedron mesh;</div>
<div class="line">  <a class="code" href="group__PMP__repairing__grp.html#ga0dec58e8a0112791f72ebbe77bac074b">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh</a>(points, polygons, mesh);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number the faces because &#39;orient_to_bound_a_volume&#39; needs a face &lt;--&gt; index map</span></div>
<div class="line">  <span class="keywordtype">int</span> index = 0;</div>
<div class="line">  <span class="keywordflow">for</span>(Polyhedron::Face_iterator fb=mesh.facets_begin(), fe=mesh.facets_end(); fb!=fe; ++fb)</div>
<div class="line">    fb-&gt;id() = index++;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>(<a class="codeRef" href="../BGL/group__PkgBGLHelperFct.html#gae04c8044cf1eee6a84baa5b79ab99fef">CGAL::is_closed</a>(mesh))</div>
<div class="line">    <a class="code" href="group__PMP__orientation__grp.html#gafdbc256d06536f6aca2558bc1a0156e2">CGAL::Polygon_mesh_processing::orient_to_bound_a_volume</a>(mesh);</div>
<div class="line"> </div>
<div class="line">  std::ofstream out(<span class="stringliteral">&quot;tet-oriented1.off&quot;</span>);</div>
<div class="line">  out.precision(17);</div>
<div class="line">  out &lt;&lt; mesh;</div>
<div class="line">  out.close();</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__PMP__orientation__grp.html#gad8a3439883e3e76651f96d15ba58b2bc">CGAL::Polygon_mesh_processing::reverse_face_orientations</a>(mesh);</div>
<div class="line">  std::ofstream out2(<span class="stringliteral">&quot;tet-oriented2.off&quot;</span>);</div>
<div class="line">  out2.precision(17);</div>
<div class="line">  out2 &lt;&lt; mesh;</div>
<div class="line">  out2.close();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This example shows how to correctly repair and orient a soup to get a mesh from a reference :</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2orientation_pipeline_example_8cpp-example.html">Polygon_mesh_processing/orientation_pipeline_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/orientation.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/orient_polygon_soup_extension.h&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/algorithm.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line">  <span class="keyword">typedef</span> K::Point_3 Point_3;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="codeRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> Mesh;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Point_3&gt; points;</div>
<div class="line">  std::vector&lt; std::vector&lt;std::size_t&gt; &gt; polygons;</div>
<div class="line">  Mesh ref1;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* input_filename = argc&lt;2 ? <span class="stringliteral">&quot;data/blobby-shuffled.off&quot;</span> : argv[1];</div>
<div class="line">  std::ifstream input(input_filename);</div>
<div class="line">  <span class="keywordflow">if</span> ( !input){</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: can not read input file.\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">typedef</span>  K::Point_3 Point_3;</div>
<div class="line">  CGAL::File_scanner_OFF scanner(input);</div>
<div class="line">  points.resize(scanner.size_of_vertices());</div>
<div class="line">  polygons.resize(scanner.size_of_facets());</div>
<div class="line">  <span class="comment">//read points</span></div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; scanner.size_of_vertices(); ++i)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">double</span> x, y, z, w;</div>
<div class="line">    scanner.scan_vertex( x, y, z, w);</div>
<div class="line">    points[i] = Point_3(x, y, z, w);</div>
<div class="line">    scanner.skip_to_next_vertex( i);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">//read triangles</span></div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; scanner.size_of_facets(); ++i)</div>
<div class="line">   {</div>
<div class="line">     std::size_t no;</div>
<div class="line">     scanner.scan_facet( no, i);</div>
<div class="line">     polygons[i].resize(no);</div>
<div class="line"> </div>
<div class="line">     <span class="keywordflow">for</span>(std::size_t j = 0; j &lt; no; ++j) {</div>
<div class="line">       std::size_t id;</div>
<div class="line">       scanner.scan_facet_vertex_index(<span class="keywordtype">id</span>, i);</div>
<div class="line">       <span class="keywordflow">if</span>(<span class="keywordtype">id</span> &lt; scanner.size_of_vertices())</div>
<div class="line">       {</div>
<div class="line">         polygons[i][j] = id;</div>
<div class="line">       }</div>
<div class="line">       <span class="keywordflow">else</span></div>
<div class="line">       {</div>
<div class="line">         std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: input file not valid.\n&quot;</span>;</div>
<div class="line">         <span class="keywordflow">return</span> 1;</div>
<div class="line">       }</div>
<div class="line">     }</div>
<div class="line">   }</div>
<div class="line">  input.close();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>(points.size() == 0 || polygons.size()==0)</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: input file not valid.\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* reference_filename = argc&lt;2 ? <span class="stringliteral">&quot;data/blobby.off&quot;</span> : argv[2];</div>
<div class="line">  input.open(reference_filename);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> ( !input || !(input &gt;&gt; ref1)){</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: can not read reference file.\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line">  input.close();</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Is the soup a polygon mesh ? : &quot;</span></div>
<div class="line">            &lt;&lt; <a class="code" href="group__PMP__repairing__grp.html#ga8b9d12d817b5cc76f5a42d74eac75bf3">CGAL::Polygon_mesh_processing::is_polygon_soup_a_polygon_mesh</a>(polygons)</div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  CGAL::Polygon_mesh_processing::orient_triangle_soup_with_reference_triangle_mesh&lt;CGAL::Sequential_tag&gt;(ref1, points, polygons);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;And now ? : &quot;</span></div>
<div class="line">            &lt;&lt; <a class="code" href="group__PMP__repairing__grp.html#ga8b9d12d817b5cc76f5a42d74eac75bf3">CGAL::Polygon_mesh_processing::is_polygon_soup_a_polygon_mesh</a>(polygons)</div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__PMP__orientation__grp.html#ga2aa4f7b500dc51d1fc4747705a050946">CGAL::Polygon_mesh_processing::duplicate_non_manifold_edges_in_polygon_soup</a>(points, polygons);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;And now ? : &quot;</span></div>
<div class="line">            &lt;&lt; <a class="code" href="group__PMP__repairing__grp.html#ga8b9d12d817b5cc76f5a42d74eac75bf3">CGAL::Polygon_mesh_processing::is_polygon_soup_a_polygon_mesh</a>(polygons)</div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  Mesh poly;</div>
<div class="line">  <a class="code" href="group__PMP__repairing__grp.html#ga0dec58e8a0112791f72ebbe77bac074b">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh</a>(</div>
<div class="line">        points, polygons, poly);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;Mesh, CGAL::dynamic_face_property_t&lt;std::size_t&gt; &gt;::type Fccmap;</div>
<div class="line">  Fccmap fccmap = get(<a class="codeRef" href="../BGL/structCGAL_1_1dynamic__face__property__t.html">CGAL::dynamic_face_property_t&lt;std::size_t&gt;</a>(), poly);</div>
<div class="line"> </div>
<div class="line">  std::cout&lt;&lt;<a class="code" href="group__keep__connected__components__grp.html#gabe2052b2281e1e628e68d8fea94be2d9">CGAL::Polygon_mesh_processing::</a></div>
<div class="line"><a class="code" href="group__keep__connected__components__grp.html#gabe2052b2281e1e628e68d8fea94be2d9">         connected_components</a>(poly, fccmap)&lt;&lt;<span class="stringliteral">&quot; CCs before merge.&quot;</span>&lt;&lt;std::endl;</div>
<div class="line">  <a class="code" href="group__PMP__orientation__grp.html#gae25c1198a89c53d5df2f29dd57fda5ca">CGAL::Polygon_mesh_processing::</a></div>
<div class="line"><a class="code" href="group__PMP__orientation__grp.html#gae25c1198a89c53d5df2f29dd57fda5ca">      merge_reversible_connected_components</a>(poly);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::cout&lt;&lt;<a class="code" href="group__keep__connected__components__grp.html#gabe2052b2281e1e628e68d8fea94be2d9">CGAL::Polygon_mesh_processing::</a></div>
<div class="line"><a class="code" href="group__keep__connected__components__grp.html#gabe2052b2281e1e628e68d8fea94be2d9">         connected_components</a>(poly, fccmap)&lt;&lt;<span class="stringliteral">&quot; remaining CCs.&quot;</span>&lt;&lt;std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="PMPRepairing"></a>
Combinatorial Repairing</h1>
<h2><a class="anchor" id="PSRepairing"></a>
Polygon Soup Repairing</h2>
<p>To ensure that a polygon soup can be oriented (see Section <a class="el" href="index.html#PolygonSoups">Polygon Soups</a>) and transformed into a workable polygon mesh, it might be necessary to preprocess the data to remove combinatorial and geometrical errors. This package offers the following functions:</p><ul>
<li><code><a class="el" href="group__PMP__repairing__grp.html#ga14042207f91907f139aff40b103824f4">CGAL::Polygon_mesh_processing::merge_duplicate_points_in_polygon_soup()</a></code>,</li>
<li><code><a class="el" href="group__PMP__repairing__grp.html#ga8fbe2f858697ae665b8e44fad31bae6b">CGAL::Polygon_mesh_processing::merge_duplicate_polygons_in_polygon_soup()</a></code>,</li>
<li><code><a class="el" href="group__PMP__repairing__grp.html#gaef5c13fc9dd4cae14c860351c479a45f">CGAL::Polygon_mesh_processing::remove_isolated_points_in_polygon_soup()</a></code>,</li>
</ul>
<p>as well as the function <code><a class="el" href="group__PMP__repairing__grp.html#ga4a8bf46e90d0cd94e1edf7ed90d42f2f">CGAL::Polygon_mesh_processing::repair_polygon_soup()</a></code>, which bundles the previous functions and an additional handful of repairing techniques to obtain an as-clean-as-possible polygon soup.</p>
<h2><a class="anchor" id="Stitching"></a>
Stitching</h2>
<p>When handling polygon meshes, it might happen that a mesh has several edges and vertices that are duplicated. For those edges and vertices, the connectivity of the mesh is incomplete, if not considered incorrect.</p>
<p>Stitching the borders of a polygon mesh can be done to fix some of the duplication. It consists in two main steps. First, border edges that are geometrically identical but duplicated are detected and paired. Then, they are "stitched" together so that edges and vertices duplicates are removed from the mesh, and each of these remaining edges is incident to exactly two faces.</p>
<p>The functions <code><a class="el" href="group__PMP__repairing__grp.html#ga9c12c4878c08a117b3733bb45f1a34cf">CGAL::Polygon_mesh_processing::stitch_boundary_cycle()</a></code>, <code><a class="el" href="group__PMP__repairing__grp.html#ga24d5ae37f62064b3fc576ba48a4ccc63">CGAL::Polygon_mesh_processing::stitch_boundary_cycles()</a></code>, and <code><a class="el" href="group__PMP__repairing__grp.html#ga8ae4352e67d2b099994ac8990c13bd41">CGAL::Polygon_mesh_processing::stitch_borders()</a></code> can perform such repairing operations: the first two functions can be used to stitch halfedges that are part of the same boundary(ies), whereas the third function is more generic and can also stitch halfedges that live on different borders.</p>
<p>The input mesh should be manifold; otherwise, stitching is not guaranteed to succeed.</p>
<h3><a class="anchor" id="StitchingExample"></a>
Stitching Example</h3>
<p>The following example applies the stitching operation to a simple quad mesh with duplicated border edges.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2stitch_borders_example_8cpp-example.html">Polygon_mesh_processing/stitch_borders_example.cpp</a> </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/stitch_borders.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;K&gt;</a> Polyhedron;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/full_border_quads.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line"> </div>
<div class="line">  Polyhedron mesh;</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh) || mesh.is_empty()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Not a valid off file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Before stitching : &quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\t Number of vertices  :\t&quot;</span> &lt;&lt; mesh.size_of_vertices() &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\t Number of halfedges :\t&quot;</span> &lt;&lt; mesh.size_of_halfedges() &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\t Number of facets    :\t&quot;</span> &lt;&lt; mesh.size_of_facets() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__PMP__repairing__grp.html#ga8ae4352e67d2b099994ac8990c13bd41">CGAL::Polygon_mesh_processing::stitch_borders</a>(mesh);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Stitching done : &quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\t Number of vertices  :\t&quot;</span> &lt;&lt; mesh.size_of_vertices() &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\t Number of halfedges :\t&quot;</span> &lt;&lt; mesh.size_of_halfedges() &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\t Number of facets    :\t&quot;</span> &lt;&lt; mesh.size_of_facets() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::ofstream output(<span class="stringliteral">&quot;mesh_stitched.off&quot;</span>);</div>
<div class="line">  output.precision(17);</div>
<div class="line">  output &lt;&lt; std::setprecision(17) &lt;&lt; mesh;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="PMPManifoldness"></a>
Polygon Mesh Manifoldness</h2>
<p>This package offers repairing methods to clean ill-formed polygon soups, see Section <a class="el" href="index.html#PMPRepairing">Combinatorial Repairing</a>.</p>
<p>Non-manifold vertices can be detected using the function <code><a class="el" href="group__PMP__repairing__grp.html#ga121f588ac324938d9a6b6931a08661e1">CGAL::Polygon_mesh_processing::is_non_manifold_vertex()</a></code>. The function <code><a class="el" href="group__PMP__repairing__grp.html#ga71b69817fe09aa9b6d366a67e1c635ce">CGAL::Polygon_mesh_processing::duplicate_non_manifold_vertices()</a></code> can be used to attempt to create a combinatorially manifold surface mesh by splitting any non-manifold vertex into as many vertices as there are manifold sheets at this geometric position. Note however that the mesh will still not be manifold from a geometric point of view, as the positions of the new vertices introduced at a non-manifold vertex are identical to the input non-manifold vertex.</p>
<h3><a class="anchor" id="FixNMVerticeExample"></a>
Manifoldness Repair Example</h3>
<p>In the following example, a non-manifold configuration is artifically created and fixed with the help of the functions described above.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2manifoldness_repair_example_8cpp-example.html">Polygon_mesh_processing/manifoldness_repair_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/iterator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/repair.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/IO/OFF_reader.h&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"><span class="keyword">namespace </span>NP = CGAL::parameters;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>          K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                               Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor                 vertex_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::halfedge_descriptor               halfedge_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> merge_vertices(vertex_descriptor v_keep, vertex_descriptor v_rm, Mesh&amp; mesh)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;merging vertices &quot;</span> &lt;&lt; v_keep &lt;&lt; <span class="stringliteral">&quot; and &quot;</span> &lt;&lt; v_rm &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(halfedge_descriptor h : <a class="codeRef" href="../BGL/group__PkgBGLIterators.html#ga2be4fd4d24b1e48e00a92f90f0f2923c">CGAL::halfedges_around_target</a>(v_rm, mesh)){</div>
<div class="line">    set_target(h, v_keep, mesh); <span class="comment">// to ensure that no halfedge points at the deleted vertex</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  remove_vertex(v_rm, mesh);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/blobby.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!input || !(input &gt;&gt; mesh) || num_vertices(mesh) == 0)</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot; is not a valid off file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Artificially create non-manifoldness for the sake of the example by merging some vertices</span></div>
<div class="line">  vertex_descriptor v0 = *(vertices(mesh).begin());</div>
<div class="line">  vertex_descriptor v1 = *(--(vertices(mesh).end()));</div>
<div class="line">  merge_vertices(v0, v1, mesh);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Count non manifold vertices</span></div>
<div class="line">  <span class="keywordtype">int</span> counter = 0;</div>
<div class="line">  <span class="keywordflow">for</span>(vertex_descriptor v : vertices(mesh))</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__PMP__repairing__grp.html#ga121f588ac324938d9a6b6931a08661e1">PMP::is_non_manifold_vertex</a>(v, mesh))</div>
<div class="line">    {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;vertex &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; is non-manifold&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      ++counter;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; counter &lt;&lt; <span class="stringliteral">&quot; non-manifold occurrence(s)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Fix manifoldness by splitting non-manifold vertices</span></div>
<div class="line">  std::vector&lt;std::vector&lt;vertex_descriptor&gt; &gt; duplicated_vertices;</div>
<div class="line">  std::size_t new_vertices_nb = <a class="code" href="group__PMP__repairing__grp.html#ga71b69817fe09aa9b6d366a67e1c635ce">PMP::duplicate_non_manifold_vertices</a>(mesh,</div>
<div class="line">                                                                     NP::output_iterator(</div>
<div class="line">                                                                       std::back_inserter(duplicated_vertices)));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; new_vertices_nb &lt;&lt; <span class="stringliteral">&quot; vertices have been added to fix mesh manifoldness&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(std::size_t i=0; i&lt;duplicated_vertices.size(); ++i)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Non-manifold vertex &quot;</span> &lt;&lt; duplicated_vertices[i].front() &lt;&lt; <span class="stringliteral">&quot; was fixed by creating&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>(std::size_t j=1; j&lt;duplicated_vertices[i].size(); ++j)</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; duplicated_vertices[i][j];</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="PMPDuplicateVertexBoundaryCycle"></a>
Duplicated Vertices in Boundary Cycles</h2>
<p>Similarly to the problematic configuration described in the previous section, another issue that can be present in a polygon mesh is the occurrence of a "pinched" hole, that is the configuration where, when starting from a border halfedge and walking the halfedges of this border, a geometric position appears more than once (although, with different vertices) before reaching the initial border halfedge again. The functions <code><a class="el" href="group__PMP__repairing__grp.html#ga49fdb6be166d8a25aeb68e84a62a8cab">CGAL::Polygon_mesh_processing::merge_duplicated_vertices_in_boundary_cycle()</a></code> and <code><a class="el" href="group__PMP__repairing__grp.html#ga49fdb6be166d8a25aeb68e84a62a8cab">CGAL::Polygon_mesh_processing::merge_duplicated_vertices_in_boundary_cycle()</a></code>, which merge vertices at identical positions, can be used to repair this configuration.</p>
<h1><a class="anchor" id="PMPNormalComp"></a>
Computing Normals</h1>
<p>This package provides methods to compute normals on the polygon mesh. The normal can either be computed for each single face, or estimated for each vertex, as the average of its incident face normals. These computations are performed with :</p><ul>
<li><code><a class="el" href="group__PMP__normal__grp.html#gaa76c6d307b9d3e48cafacd7b77b2c043">CGAL::Polygon_mesh_processing::compute_face_normal()</a></code></li>
<li><code><a class="el" href="group__PMP__normal__grp.html#ga240ed0a1f5efbea472f998fada07e112">CGAL::Polygon_mesh_processing::compute_vertex_normal()</a></code></li>
</ul>
<p>Furthermore, we provide functions to compute all the normals to faces, or to vertices, or to both :</p><ul>
<li><code><a class="el" href="group__PMP__normal__grp.html#gac4f70adfa9f0fed9a9e6cdb415c6bd14">CGAL::Polygon_mesh_processing::compute_face_normals()</a></code></li>
<li><code><a class="el" href="group__PMP__normal__grp.html#gabc5c8980b59bbd464d646c4b4aa31baa">CGAL::Polygon_mesh_processing::compute_vertex_normals()</a></code></li>
<li><code><a class="el" href="group__PMP__normal__grp.html#gaa905e5eb07ffeef1433d22a057959cc1">CGAL::Polygon_mesh_processing::compute_normals()</a></code>.</li>
</ul>
<p>Property maps are used to record the computed normals.</p>
<h2><a class="anchor" id="NormalsExample"></a>
Normals Computation Examples</h2>
<p>Property maps are an API introduced in the boost library that allows to associate values to keys. In the following examples we associate a normal vector to each vertex and to each face.</p>
<h3><a class="anchor" id="NormalsExampleSM"></a>
Normals Computation for a Surface Mesh</h3>
<p>The following example illustrates how to compute the normals to faces and vertices and store them in property maps provided by the class <code><a class="elRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code>.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2compute_normals_example_8cpp-example.html">Polygon_mesh_processing/compute_normals_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/compute_normal.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>       K;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> K::Point_3                                                Point;</div>
<div class="line"><span class="keyword">typedef</span> K::Vector_3                                               Vector;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                                 Surface_mesh;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Surface_mesh&gt;::vertex_descriptor      vertex_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Surface_mesh&gt;::face_descriptor        face_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/eight.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line"> </div>
<div class="line">  Surface_mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh) || mesh.is_empty()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Not a valid off file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> vnormals = mesh.add_property_map&lt;vertex_descriptor, Vector&gt;(<span class="stringliteral">&quot;v:normals&quot;</span>, <a class="codeRef" href="../Kernel_23/group__kernel__enums.html#ga4a98ec6bd9dfd8fe8c46fea553b5d238">CGAL::NULL_VECTOR</a>).first;</div>
<div class="line">  <span class="keyword">auto</span> fnormals = mesh.add_property_map&lt;face_descriptor, Vector&gt;(<span class="stringliteral">&quot;f:normals&quot;</span>, <a class="codeRef" href="../Kernel_23/group__kernel__enums.html#ga4a98ec6bd9dfd8fe8c46fea553b5d238">CGAL::NULL_VECTOR</a>).first;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__PMP__normal__grp.html#gaa905e5eb07ffeef1433d22a057959cc1">PMP::compute_normals</a>(mesh, vnormals, fnormals);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Vertex normals :&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd: vertices(mesh))</div>
<div class="line">    std::cout &lt;&lt; vnormals[vd] &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Face normals :&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span>(face_descriptor fd: faces(mesh))</div>
<div class="line">    std::cout &lt;&lt; fnormals[fd] &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="NormalsExampleP"></a>
Normals Computation for a Polyhedron_3</h3>
<p>The following example illustrates how to compute the normals to faces and vertices and store them in ordered or unordered maps as the class <code><a class="elRef" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> does not provide storage for the normals.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2compute_normals_example_Polyhedron_8cpp-example.html">Polygon_mesh_processing/compute_normals_example_Polyhedron.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/compute_normal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/property_map/property_map.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"><span class="comment">// #include &lt;CGAL/Unique_hash_map.h&gt;</span></div>
<div class="line"><span class="comment">// #include &lt;boost/unordered_map.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> K::Point_3 Point;</div>
<div class="line"><span class="keyword">typedef</span> K::Vector_3 Vector;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;K&gt;</a> Polyhedron;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor vertex_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::face_descriptor   face_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/eight.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line"> </div>
<div class="line">  Polyhedron mesh;</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh) || mesh.is_empty()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Not a valid off file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::map&lt;face_descriptor,Vector&gt; fnormals;</div>
<div class="line">  std::map&lt;vertex_descriptor,Vector&gt; vnormals;</div>
<div class="line">  <span class="comment">// Instead of std::map you may use std::unordered_map, boost::unordered_map</span></div>
<div class="line">  <span class="comment">// or CGAL::Unique_hash_map</span></div>
<div class="line">  <span class="comment">// CGAL::Unique_hash_map&lt;face_descriptor,Vector&gt; fnormals;</span></div>
<div class="line">  <span class="comment">// boost::unordered_map&lt;vertex_descriptor,Vector&gt; vnormals;</span></div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__PMP__normal__grp.html#gaa905e5eb07ffeef1433d22a057959cc1">CGAL::Polygon_mesh_processing::compute_normals</a>(mesh,</div>
<div class="line">                                                 boost::make_assoc_property_map(vnormals),</div>
<div class="line">                                                 boost::make_assoc_property_map(fnormals));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Face normals :&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span>(face_descriptor fd: faces(mesh)){</div>
<div class="line">    std::cout &lt;&lt; fnormals[fd] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Vertex normals :&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd: vertices(mesh)){</div>
<div class="line">    std::cout &lt;&lt; vnormals[vd] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="PMPSlicer"></a>
Slicer</h1>
<p>The <code><a class="el" href="classCGAL_1_1Polygon__mesh__slicer.html">CGAL::Polygon_mesh_slicer</a></code> is an operator that intersects a triangle surface mesh with a plane. It records the intersection as a set of polylines since the intersection can be made of more than one connected component. The degenerate case where the intersection is a single point is handled.</p>
<p><a class="el" href="index.html#fig__SlicerFig">fig__SlicerFig</a> shows the polylines returned by the slicing operation for a triangle mesh and a set of parallel planes.</p>
<p><a class="anchor" id="fig__SlicerFig"></a></p><div class="image">
<img src="slicer.jpg" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__SlicerFig">fig__SlicerFig</a> Slicing a mesh. A triangle mesh (left) and the polylines computed by the mesh slicer by intersecting a set of parallel planes (right). </p> </div> <p> <br  />
</p>
<h2><a class="anchor" id="SlicerExample"></a>
Slicer Example</h2>
<p>The example below illustrates how to use the mesh slicer for a given triangle mesh and a plane. Two constructors are used in the example for pedagogical purposes.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2mesh_slicer_example_8cpp-example.html">Polygon_mesh_processing/mesh_slicer_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_halfedge_graph_segment_primitive.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_tree.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_traits.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_slicer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a> Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt;K::Point_3&gt; Polyline_type;</div>
<div class="line"><span class="keyword">typedef</span> std::list&lt; Polyline_type &gt; Polylines;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../AABB_tree/classCGAL_1_1AABB__halfedge__graph__segment__primitive.html">CGAL::AABB_halfedge_graph_segment_primitive&lt;Mesh&gt;</a> HGSP;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../AABB_tree/classCGAL_1_1AABB__traits.html">CGAL::AABB_traits&lt;K, HGSP&gt;</a>    AABB_traits;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../AABB_tree/classCGAL_1_1AABB__tree.html">CGAL::AABB_tree&lt;AABB_traits&gt;</a>  AABB_tree;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/eight.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh) || mesh.is_empty()</div>
<div class="line">             || !<a class="codeRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh)) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Not a valid input file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Slicer constructor from the mesh</span></div>
<div class="line">  <a class="code" href="classCGAL_1_1Polygon__mesh__slicer.html">CGAL::Polygon_mesh_slicer&lt;Mesh, K&gt;</a> slicer(mesh);</div>
<div class="line"> </div>
<div class="line">  Polylines polylines;</div>
<div class="line">  slicer(K::Plane_3(0, 0, 1, -0.4), std::back_inserter(polylines));</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;At z = 0.4, the slicer intersects &quot;</span></div>
<div class="line">            &lt;&lt; polylines.size() &lt;&lt; <span class="stringliteral">&quot; polylines&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  polylines.clear();</div>
<div class="line"> </div>
<div class="line">  slicer(K::Plane_3(0, 0, 1, 0.2), std::back_inserter(polylines));</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;At z = -0.2, the slicer intersects &quot;</span></div>
<div class="line">            &lt;&lt; polylines.size() &lt;&lt; <span class="stringliteral">&quot; polylines&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  polylines.clear();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Use the Slicer constructor from a pre-built AABB_tree</span></div>
<div class="line">  AABB_tree tree(edges(mesh).first, edges(mesh).second, mesh);</div>
<div class="line">  <a class="code" href="classCGAL_1_1Polygon__mesh__slicer.html">CGAL::Polygon_mesh_slicer&lt;Mesh, K&gt;</a> slicer_aabb(mesh, tree);</div>
<div class="line">  slicer_aabb(K::Plane_3(0, 0, 1, -0.4), std::back_inserter(polylines));</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;At z = 0.4, the slicer intersects &quot;</span></div>
<div class="line">            &lt;&lt; polylines.size() &lt;&lt; <span class="stringliteral">&quot; polylines&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  polylines.clear();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="PMPConnectedComponents"></a>
Connected Components</h1>
<p>This package provides functions to enumerate and store the connected components of a polygon mesh. The connected components can be either closed and geometrically separated, or separated by border or user-specified <em>constraint</em> edges.</p>
<p>First, the function <code><a class="el" href="group__keep__connected__components__grp.html#gad2546bc14c00bac66d87161a4044f871">CGAL::Polygon_mesh_processing::connected_component()</a></code> collects all the faces that belong to the same connected component as the face that is given as a parameter.</p>
<p>Then, <code><a class="el" href="group__keep__connected__components__grp.html#gabe2052b2281e1e628e68d8fea94be2d9">CGAL::Polygon_mesh_processing::connected_components()</a></code> collects all the connected components, and fills a property map with the indices of the different connected components.</p>
<p>The functions <code><a class="el" href="group__keep__connected__components__grp.html#ga7dd1414e9366fed26c1f12c12c376b39">CGAL::Polygon_mesh_processing::keep_connected_components()</a></code> and <code><a class="el" href="group__keep__connected__components__grp.html#ga17cb532198888791f2ceb00666f4c1d4">CGAL::Polygon_mesh_processing::remove_connected_components()</a></code> enable the user to keep and remove only a selection of connected components, provided either as a range of faces that belong to the desired connected components or as a range of connected component ids (one or more per connected component).</p>
<p>When a triangle mesh has no boundary, it partitions the 3D space in different volumes. The function <code><a class="el" href="group__PMP__orientation__grp.html#ga133e58280959c152770525f27bb42b91">CGAL::Polygon_mesh_processing::volume_connected_components()</a></code> can be used to assign to each face an id per volume defined by the surface connected components.</p>
<p>Finally, it can be useful to quickly remove some connected components, for example for noisy data where small connected components should be discarded in favor of major connected components. The function <code><a class="el" href="group__keep__connected__components__grp.html#ga68c6c29dfc6a26a6a2f8befe6944f19d">CGAL::Polygon_mesh_processing::keep_largest_connected_components()</a></code> enables the user to keep only a given number from the largest connected components. The size of a connected component is given by the sum of the sizes of the faces it contains; by default, the size of a face is <code>1</code> and thus the size of a connected component is equal to the number of faces it contains. However, it is also possible to pass a face size map, such that the size of the face is its area, for example. Similarly to the previous function, the function <code><a class="el" href="group__keep__connected__components__grp.html#ga48e7b3e6922ee78cf8ce801e3e325d9a">CGAL::Polygon_mesh_processing::keep_large_connected_components()</a></code> can be used to discard all connected components whose size is below a user-defined threshold.</p>
<p>Also, the function <code><a class="el" href="group__keep__connected__components__grp.html#ga9ddd1e4b915a4232b1ce5611985302aa">CGAL::Polygon_mesh_processing::split_connected_components()</a></code> enables the user to split the connected components of a polygon mesh in as many polygon meshes.</p>
<h2><a class="anchor" id="CCExample"></a>
Connected Components Example</h2>
<p>The first example shows how to record the connected components of a polygon mesh. In particular, we provide an example for the optional parameter <code>EdgeConstraintMap</code>, a property map that returns information about an edge being a <em>constraint</em> or not. A <em>constraint</em> provides a mean to demarcate the border of a connected component, and prevents the propagation of a connected component index to cross it.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2connected_components_example_8cpp-example.html">Polygon_mesh_processing/connected_components_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/connected_components.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/function_output_iterator.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/property_map/property_map.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="codeRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                     Point;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classKernel.html#a00792fd1a5d950d54a750f4aa9d2ba3f">Kernel::Compare_dihedral_angle_3</a>                    Compare_dihedral_angle_3;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                           Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> G&gt;</div>
<div class="line"><span class="keyword">struct </span>Constraint : <span class="keyword">public</span> boost::put_get_helper&lt;bool,Constraint&lt;G&gt; &gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;G&gt;::edge_descriptor edge_descriptor;</div>
<div class="line">  <span class="keyword">typedef</span> boost::readable_property_map_tag      category;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">bool</span>                                  value_type;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">bool</span>                                  reference;</div>
<div class="line">  <span class="keyword">typedef</span> edge_descriptor                       key_type;</div>
<div class="line"> </div>
<div class="line">  Constraint()</div>
<div class="line">    :g_(NULL)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  Constraint(G&amp; g, <span class="keywordtype">double</span> bound)</div>
<div class="line">    : g_(&amp;g), bound_(bound)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> operator[](edge_descriptor e)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keyword">const</span> G&amp; g = *g_;</div>
<div class="line">    <span class="keywordflow">return</span> compare_(g.point(source(e, g)),</div>
<div class="line">                    g.point(target(e, g)),</div>
<div class="line">                    g.point(target(next(halfedge(e, g), g), g)),</div>
<div class="line">                    g.point(target(next(<a class="codeRef" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(halfedge(e, g), g), g), g)),</div>
<div class="line">                   bound_) == <a class="codeRef" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b">CGAL::SMALLER</a>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> G* g_;</div>
<div class="line">  Compare_dihedral_angle_3 compare_;</div>
<div class="line">  <span class="keywordtype">double</span> bound_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PM&gt;</div>
<div class="line"><span class="keyword">struct </span>Put_true</div>
<div class="line">{</div>
<div class="line">  Put_true(<span class="keyword">const</span> PM pm)</div>
<div class="line">    :pm(pm)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> T&amp; t)</div>
<div class="line">  {</div>
<div class="line">    put(pm, t, <span class="keyword">true</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  PM pm;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/blobby_3cc.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh) || mesh.is_empty()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Not a valid off file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor face_descriptor;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> bound = std::cos(0.75 * CGAL_PI);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;face_descriptor&gt; cc;</div>
<div class="line">  face_descriptor fd = *faces(mesh).first;</div>
<div class="line">  <a class="code" href="group__keep__connected__components__grp.html#gad2546bc14c00bac66d87161a4044f871">PMP::connected_component</a>(fd,</div>
<div class="line">      mesh,</div>
<div class="line">      std::back_inserter(cc));</div>
<div class="line"> </div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;Connected components without edge constraints&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cerr &lt;&lt; cc.size() &lt;&lt; <span class="stringliteral">&quot; faces in the CC of &quot;</span> &lt;&lt; fd &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Instead of writing the faces into a container, you can set a face property to true</span></div>
<div class="line">  <span class="keyword">typedef</span> Mesh::Property_map&lt;face_descriptor, bool&gt; F_select_map;</div>
<div class="line">  F_select_map fselect_map =</div>
<div class="line">    mesh.add_property_map&lt;face_descriptor, <span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;f:select&quot;</span>, <span class="keyword">false</span>).first;</div>
<div class="line">  <a class="code" href="group__keep__connected__components__grp.html#gad2546bc14c00bac66d87161a4044f871">PMP::connected_component</a>(fd,</div>
<div class="line">      mesh,</div>
<div class="line">      boost::make_function_output_iterator(Put_true&lt;F_select_map&gt;(fselect_map)));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;\nConnected components with edge constraints (dihedral angle &lt; 3/4 pi)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  Mesh::Property_map&lt;face_descriptor, std::size_t&gt; fccmap =</div>
<div class="line">    mesh.add_property_map&lt;face_descriptor, std::size_t&gt;(<span class="stringliteral">&quot;f:CC&quot;</span>).first;</div>
<div class="line">  std::size_t num = <a class="code" href="group__keep__connected__components__grp.html#gabe2052b2281e1e628e68d8fea94be2d9">PMP::connected_components</a>(mesh,</div>
<div class="line">      fccmap,</div>
<div class="line">      PMP::parameters::edge_is_constrained_map(Constraint&lt;Mesh&gt;(mesh, bound)));</div>
<div class="line"> </div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;- The graph has &quot;</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">&quot; connected components (face connectivity)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keyword">typedef</span> std::map&lt;std::size_t<span class="comment">/*index of CC*/</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="comment">/*nb*/</span>&gt; Components_size;</div>
<div class="line">  Components_size nb_per_cc;</div>
<div class="line">  <span class="keywordflow">for</span>(face_descriptor f : faces(mesh)){</div>
<div class="line">    nb_per_cc[ fccmap[f] ]++;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> Components_size::value_type&amp; cc : nb_per_cc){</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;\t CC #&quot;</span> &lt;&lt; cc.first</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; is made of &quot;</span> &lt;&lt; cc.second &lt;&lt; <span class="stringliteral">&quot; faces&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;- We keep only components which have at least 4 faces&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <a class="code" href="group__keep__connected__components__grp.html#ga48e7b3e6922ee78cf8ce801e3e325d9a">PMP::keep_large_connected_components</a>(mesh,</div>
<div class="line">      4,</div>
<div class="line">      PMP::parameters::edge_is_constrained_map(Constraint&lt;Mesh&gt;(mesh, bound)));</div>
<div class="line"> </div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;- We keep the two largest components&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <a class="code" href="group__keep__connected__components__grp.html#ga68c6c29dfc6a26a6a2f8befe6944f19d">PMP::keep_largest_connected_components</a>(mesh,</div>
<div class="line">      2,</div>
<div class="line">      PMP::parameters::edge_is_constrained_map(Constraint&lt;Mesh&gt;(mesh, bound)));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The second example shows how to use the class template <code><a class="elRef" href="../BGL/structCGAL_1_1Face__filtered__graph.html">Face_filtered_graph</a></code> which enables to treat one or several connected components as a face graph.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2face_filtered_graph_example_8cpp-example.html">Polygon_mesh_processing/face_filtered_graph_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/connected_components.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/Face_filtered_graph.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;boost/property_map/property_map.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="codeRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                     Point;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                           Mesh;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor          face_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::faces_size_type          faces_size_type;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> Mesh::Property_map&lt;face_descriptor, faces_size_type&gt; FCCmap;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="codeRef" href="../BGL/structCGAL_1_1Face__filtered__graph.html">CGAL::Face_filtered_graph&lt;Mesh&gt;</a> Filtered_graph;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  std::ifstream input((argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/blobby_3cc.off&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh) || mesh.is_empty()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Not a valid off file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  FCCmap fccmap = mesh.add_property_map&lt;face_descriptor, faces_size_type&gt;(<span class="stringliteral">&quot;f:CC&quot;</span>).first;</div>
<div class="line"> </div>
<div class="line">  faces_size_type num = <a class="code" href="group__keep__connected__components__grp.html#gabe2052b2281e1e628e68d8fea94be2d9">PMP::connected_components</a>(mesh,fccmap);</div>
<div class="line"> </div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;- The graph has &quot;</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">&quot; connected components (face connectivity)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  Filtered_graph ffg(mesh, 0, fccmap);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The faces in component 0 are:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span>(boost::graph_traits&lt;Filtered_graph&gt;::face_descriptor f : faces(ffg)){</div>
<div class="line">    std::cout  &lt;&lt; f &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>(num&gt;1){</div>
<div class="line">    std::vector&lt;faces_size_type&gt; components;</div>
<div class="line">    components.push_back(0);</div>
<div class="line">    components.push_back(1);</div>
<div class="line"> </div>
<div class="line">    ffg.set_selected_faces(components, fccmap);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The faces in components 0 and 1 are:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">for</span>(Filtered_graph::face_descriptor f : faces(ffg)){</div>
<div class="line">    std::cout  &lt;&lt; f &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><h1><a class="anchor" id="PMPDistance"></a>
Approximate Hausdorff Distance</h1>
<p>This package provides methods to compute (approximate) distances between meshes and point sets.</p>
<p>The function <a class="el" href="group__PMP__distance__grp.html#ga2b28867dc150931b2f12d17b77d15266"><code>approximate_Hausdorff_distance()</code></a> computes an approximation of the Hausdorff distance from a mesh <code>tm1</code> to a mesh <code>tm2</code>. Given a a sampling of <code>tm1</code>, it computes the distance to <code>tm2</code> of the farthest sample point to <code>tm2</code> <a class="el" href="citelist.html#CITEREF_cignoni1998metro">[5]</a>. The symmetric version (<a class="el" href="group__PMP__distance__grp.html#gaa5c83a2d9e8c1251e1ca3f2cdd59785c"><code>approximate_symmetric_Hausdorff_distance()</code></a>) is the maximum of the two non-symmetric distances. Internally, points are sampled using <a class="el" href="group__PMP__distance__grp.html#ga506b11b02a3b108ba97cccbf5d78a513"><code>sample_triangle_mesh()</code></a> and the distance to each sample point is computed using <a class="el" href="group__PMP__distance__grp.html#ga44609a1b94f1ede1c87b2cfdc441d966"><code>max_distance_to_triangle_mesh()</code></a>. The quality of the approximation depends on the quality of the sampling and the runtime depends on the number of sample points. Three sampling methods with different parameters are provided (see <a class="el" href="index.html#fig__sampling_bunny">fig__sampling_bunny</a>).</p>
<p><a class="anchor" id="fig__sampling_bunny"></a></p><div class="image">
<img src="pmp_sampling_bunny.jpg" alt=""/>
</div>
   <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__sampling_bunny">fig__sampling_bunny</a> Sampling of a triangle mesh using different sampling methods. From left to right: (a) Grid sampling, (b) Monte-Carlo sampling with fixed number of points per face and per edge, (c) Monte-Carlo sampling with a number of points proportional to the area/length, and (d) Uniform random sampling. The four pictures represent the sampling on the same portion of a mesh, parameters were adjusted so that the total number of points sampled in faces (blue points) and on edges (red points) are roughly the same. Note that when using the random uniform sampling some faces/edges may not contain any point, but this method is the only one that allows to exactly match a given number of points. </p> </div> <p> <br  />
</p>
<p>The function <a class="el" href="group__PMP__distance__grp.html#ga349ddbf7a4a44e820794dbe4680d0026"><code>approximate_max_distance_to_point_set()</code></a> computes an approximation of the Hausdorff distance from a mesh to a point set. For each triangle, a lower and upper bound of the Hausdorff distance to the point set are computed. Triangles are refined until the difference between the bounds is lower than a user-defined precision threshold.</p>
<h2><a class="anchor" id="AHDExample"></a>
Approximate Hausdorff Distance Example</h2>
<p>In the following example, a mesh is isotropically remeshed and the approximate distance between the input and the output is computed.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2hausdorff_distance_remeshing_example_8cpp-example.html">Polygon_mesh_processing/hausdorff_distance_remeshing_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/distance.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/remesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define TAG CGAL::Parallel_if_available_tag</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> K::Point_3                     Point;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a> Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Mesh tm1, tm2;</div>
<div class="line">  <a class="codeRef" href="../BGL/group__PkgBGLHelperFct.html#gad2e132763721d8e4fd22020c1665c15f">CGAL::make_tetrahedron</a>(Point(.0,.0,.0),</div>
<div class="line">                         Point(2,.0,.0),</div>
<div class="line">                         Point(1,1,1),</div>
<div class="line">                         Point(1,.0,2),</div>
<div class="line">                         tm1);</div>
<div class="line">  tm2=tm1;</div>
<div class="line">  <a class="code" href="group__PMP__meshing__grp.html#gad3d03890515ae8103bd32a30a3486412">CGAL::Polygon_mesh_processing::isotropic_remeshing</a>(tm2.faces(),.05, tm2);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Approximated Hausdorff distance: &quot;</span></div>
<div class="line">            &lt;&lt; <a class="code" href="group__PMP__distance__grp.html#ga2b28867dc150931b2f12d17b77d15266">CGAL::Polygon_mesh_processing::approximate_Hausdorff_distance</a></div>
<div class="line">                  &lt;TAG&gt;(tm1, tm2, PMP::parameters::number_of_points_per_area_unit(4000))</div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="PoissonDistanceExample"></a>
Max Distance Between Point Set and Surface Example</h2>
<p>In <a class="el" href="Poisson_surface_reconstruction_3_2poisson_reconstruction_example_8cpp-example.html">Poisson_surface_reconstruction_3/poisson_reconstruction_example.cpp</a>, a triangulated surface mesh is constructed from a point set using the <a class="el" href="">Poisson reconstruction algorithm </a>, and the distance between the point set and the reconstructed surface is computed with the following code:</p>
<div class="fragment"><div class="line">    <span class="comment">// computes the approximation error of the reconstruction</span></div>
<div class="line">    <span class="keywordtype">double</span> max_dist =</div>
<div class="line">      <a class="code" href="group__PMP__distance__grp.html#ga349ddbf7a4a44e820794dbe4680d0026">CGAL::Polygon_mesh_processing::approximate_max_distance_to_point_set</a></div>
<div class="line">      (output_mesh,</div>
<div class="line">       CGAL::make_range (boost::make_transform_iterator</div>
<div class="line">                         (points.begin(), <a class="codeRef" href="../Property_map/structCGAL_1_1Property__map__to__unary__function.html">CGAL::Property_map_to_unary_function&lt;Point_map&gt;</a>()),</div>
<div class="line">                         boost::make_transform_iterator</div>
<div class="line">                         (points.end(), <a class="codeRef" href="../Property_map/structCGAL_1_1Property__map__to__unary__function.html">CGAL::Property_map_to_unary_function&lt;Point_map&gt;</a>())),</div>
<div class="line">       4000);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Max distance to point_set: &quot;</span> &lt;&lt; max_dist &lt;&lt; std::endl;</div>
</div><!-- fragment --> <h1><a class="anchor" id="PMPDetectFeatures"></a>
Feature Detection</h1>
<p>This package provides methods to detect some features of a polygon mesh.</p>
<p>The function <code><a class="el" href="group__PMP__detect__features__grp.html#ga1daa8515d6867e977c470a53dfb93838">CGAL::Polygon_mesh_processing::sharp_edges_segmentation()</a></code> detects the sharp edges of a polygon mesh and deduces surface patches and vertices incidences. It can be split into three functions : <code><a class="el" href="group__PMP__detect__features__grp.html#ga1e5e8ae3b4b8fc06270a50a48d92036d">CGAL::Polygon_mesh_processing::detect_sharp_edges()</a></code>, <code><a class="el" href="group__keep__connected__components__grp.html#gabe2052b2281e1e628e68d8fea94be2d9">CGAL::Polygon_mesh_processing::connected_components()</a></code> and <code><a class="el" href="group__PMP__detect__features__grp.html#gaf42fe09f2b613c78bba5dd8d8a71b58f">CGAL::Polygon_mesh_processing::detect_vertex_incident_patches()</a></code>, that respectively detect the sharp edges, compute the patch indices, and give each of <code>pmesh</code> vertices the patch indices of its incident faces.</p>
<h2><a class="anchor" id="DetectFeaturesExample"></a>
Feature Detection Example</h2>
<p>In the following example, we count how many edges of <code>pmesh</code> are incident to two faces whose normals form an angle smaller than 90 degrees, and the number of surface patches that are separated by these edges.</p>
<p><br  />
<b>File</b> <a class="el" href="Polygon_mesh_processing_2detect_features_example_8cpp-example.html">Polygon_mesh_processing/detect_features_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/detect_features.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="codeRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                      Mesh;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor          face_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">&quot;data/P.off&quot;</span>;</div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Not a valid input file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;Mesh, CGAL::edge_is_feature_t&gt;::type EIFMap;</div>
<div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;Mesh, CGAL::face_patch_id_t&lt;int&gt; &gt;::type PIMap;</div>
<div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;Mesh, CGAL::vertex_incident_patches_t&lt;int&gt; &gt;::type VIMap;</div>
<div class="line"> </div>
<div class="line">  EIFMap eif = get(CGAL::edge_is_feature, mesh);</div>
<div class="line">  PIMap pid = get(CGAL::face_patch_id_t&lt;int&gt;(), mesh);</div>
<div class="line">  VIMap vip = get(CGAL::vertex_incident_patches_t&lt;int&gt;(), mesh);</div>
<div class="line"> </div>
<div class="line">  std::size_t number_of_patches</div>
<div class="line">    = <a class="code" href="group__PMP__detect__features__grp.html#ga1daa8515d6867e977c470a53dfb93838">PMP::sharp_edges_segmentation</a>(mesh, 90, eif, pid,</div>
<div class="line">                                    PMP::parameters::vertex_incident_patches_map(vip));</div>
<div class="line"> </div>
<div class="line">  std::size_t nb_sharp_edges = 0;</div>
<div class="line">  <span class="keywordflow">for</span>(boost::graph_traits&lt;Mesh&gt;::edge_descriptor e : edges(mesh))</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(get(eif, e))</div>
<div class="line">      ++nb_sharp_edges;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot;This mesh contains &quot;</span>&lt;&lt;nb_sharp_edges&lt;&lt;<span class="stringliteral">&quot; sharp edges&quot;</span>&lt;&lt;std::endl;</div>
<div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot; and &quot;</span>&lt;&lt;number_of_patches&lt;&lt;<span class="stringliteral">&quot; surface patches.&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="PMPHistory"></a>
Implementation History</h1>
<p>A first version of this package was started by Ilker O. Yaz and Sébastien Loriot. Jane Tournois worked on the finalization of the API, code, and documentation.</p>
<p>A prototype of mesh and shape smoothing was developed during the 2017 edition of the Google Summer of Code by Konstantinos Katrioplas, under supervision of Jane Tournois. It was finalized by Mael Rouxel-Labbé and integrated in <span style="font-variant: small-caps;">CGAL</span> 5.0.</p>
<p>Functionalities related to mesh and polygon soup reparation have been introduced steadily over multiple versions since <span style="font-variant: small-caps;">CGAL</span> 4.10, in joint work between Sébastien Loriot and Mael Rouxel-Labbé. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__PMP__meshing__grp_html_gad0449d8e1021fc46507074cd6db65ef4"><div class="ttname"><a href="group__PMP__meshing__grp.html#gad0449d8e1021fc46507074cd6db65ef4">CGAL::Polygon_mesh_processing::refine</a></div><div class="ttdeci">std::pair&lt; FaceOutputIterator, VertexOutputIterator &gt; refine(TriangleMesh &amp;tmesh, const FaceRange &amp;faces, FaceOutputIterator faces_out, VertexOutputIterator vertices_out, const NamedParameters &amp;np)</div><div class="ttdoc">refines a region of a triangle mesh</div><div class="ttdef"><b>Definition:</b> refine.h:71</div></div>
<div class="ttc" id="agroup__hole__filling__grp_html_ga19bc0ac51dc9a1ee78c3e7a0d57de47d"><div class="ttname"><a href="group__hole__filling__grp.html#ga19bc0ac51dc9a1ee78c3e7a0d57de47d">CGAL::Polygon_mesh_processing::triangulate_refine_and_fair_hole</a></div><div class="ttdeci">std::tuple&lt; bool, FaceOutputIterator, VertexOutputIterator &gt; triangulate_refine_and_fair_hole(PolygonMesh &amp;pmesh, typename boost::graph_traits&lt; PolygonMesh &gt;::halfedge_descriptor border_halfedge, FaceOutputIterator face_out, VertexOutputIterator vertex_out, const NamedParameters &amp;np)</div><div class="ttdoc">triangulates, refines and fairs a hole in a polygon mesh.</div><div class="ttdef"><b>Definition:</b> triangulate_hole.h:255</div></div>
<div class="ttc" id="agroup__PMP__distance__grp_html_ga349ddbf7a4a44e820794dbe4680d0026"><div class="ttname"><a href="group__PMP__distance__grp.html#ga349ddbf7a4a44e820794dbe4680d0026">CGAL::Polygon_mesh_processing::approximate_max_distance_to_point_set</a></div><div class="ttdeci">double approximate_max_distance_to_point_set(const TriangleMesh &amp;tm, const PointRange &amp;points, const double precision, const NamedParameters &amp;np)</div><div class="ttdef"><b>Definition:</b> distance.h:1130</div></div>
<div class="ttc" id="agroup__PMP__repairing__grp_html_ga71b69817fe09aa9b6d366a67e1c635ce"><div class="ttname"><a href="group__PMP__repairing__grp.html#ga71b69817fe09aa9b6d366a67e1c635ce">CGAL::Polygon_mesh_processing::duplicate_non_manifold_vertices</a></div><div class="ttdeci">std::size_t duplicate_non_manifold_vertices(PolygonMesh &amp;pm, const NamedParameters &amp;np)</div><div class="ttdef"><b>Definition:</b> manifoldness.h:420</div></div>
<div class="ttc" id="agroup__kernel__enums_html_ggaf6030e89dadcc1f45369b0cdc5d9e111a060193157c0875fb2e6445a648f3ac1f"><div class="ttname"><a href="../Kernel_23/group__kernel__enums.html#ggaf6030e89dadcc1f45369b0cdc5d9e111a060193157c0875fb2e6445a648f3ac1f">ON_BOUNDARY</a></div><div class="ttdeci">ON_BOUNDARY</div></div>
<div class="ttc" id="agroup__PMP__corefinement__grp_html_ga240e5df984c7d44741a7031e38203dc3"><div class="ttname"><a href="group__PMP__corefinement__grp.html#ga240e5df984c7d44741a7031e38203dc3">CGAL::Polygon_mesh_processing::corefine_and_compute_intersection</a></div><div class="ttdeci">bool corefine_and_compute_intersection(TriangleMesh &amp;tm1, TriangleMesh &amp;tm2, TriangleMesh &amp;tm_out, const NamedParameters1 &amp;np1, const NamedParameters2 &amp;np2, const NamedParametersOut &amp;np_out)</div><div class="ttdef"><b>Definition:</b> corefinement.h:540</div></div>
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__inexact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></div></div>
<div class="ttc" id="agroup__kernel__enums_html_ggaf6030e89dadcc1f45369b0cdc5d9e111ad8333d35d4801c08b3a5ae9e94d7cabe"><div class="ttname"><a href="../Kernel_23/group__kernel__enums.html#ggaf6030e89dadcc1f45369b0cdc5d9e111ad8333d35d4801c08b3a5ae9e94d7cabe">ON_BOUNDED_SIDE</a></div><div class="ttdeci">ON_BOUNDED_SIDE</div></div>
<div class="ttc" id="aclassCGAL_1_1Surface__mesh_html"><div class="ttname"><a href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></div></div>
<div class="ttc" id="agroup__PkgBGLIterators_html_ga37229df31508a78eb4acdaf907e637e5"><div class="ttname"><a href="../BGL/group__PkgBGLIterators.html#ga37229df31508a78eb4acdaf907e637e5">halfedges_around_face</a></div><div class="ttdeci">Iterator_range&lt; Halfedge_around_face_iterator&lt; Graph &gt; &gt; halfedges_around_face(typename boost::graph_traits&lt; Graph &gt;::halfedge_descriptor h, const Graph &amp;g)</div></div>
<div class="ttc" id="agroup__PMP__orientation__grp_html_gad8a3439883e3e76651f96d15ba58b2bc"><div class="ttname"><a href="group__PMP__orientation__grp.html#gad8a3439883e3e76651f96d15ba58b2bc">CGAL::Polygon_mesh_processing::reverse_face_orientations</a></div><div class="ttdeci">void reverse_face_orientations(PolygonMesh &amp;pmesh)</div><div class="ttdef"><b>Definition:</b> orientation.h:270</div></div>
<div class="ttc" id="astructCGAL_1_1dynamic__face__property__t_html"><div class="ttname"><a href="../BGL/structCGAL_1_1dynamic__face__property__t.html">CGAL::dynamic_face_property_t</a></div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_gad93e429ad24efeaddeb836c437e719ab"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#gad93e429ad24efeaddeb836c437e719ab">is_border</a></div><div class="ttdeci">bool is_border(typename boost::graph_traits&lt; FaceGraph &gt;::halfedge_descriptor hd, const FaceGraph &amp;g)</div></div>
<div class="ttc" id="agroup__PMP__repairing__grp_html_ga0dec58e8a0112791f72ebbe77bac074b"><div class="ttname"><a href="group__PMP__repairing__grp.html#ga0dec58e8a0112791f72ebbe77bac074b">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh</a></div><div class="ttdeci">void polygon_soup_to_polygon_mesh(const PointRange &amp;points, const PolygonRange &amp;polygons, PolygonMesh &amp;out, const NamedParameters_PS &amp;np_ps, const NamedParameters_PM &amp;np_pm)</div><div class="ttdef"><b>Definition:</b> polygon_soup_to_polygon_mesh.h:253</div></div>
<div class="ttc" id="aclassCGAL_1_1Polygon__mesh__slicer_html"><div class="ttname"><a href="classCGAL_1_1Polygon__mesh__slicer.html">CGAL::Polygon_mesh_slicer</a></div><div class="ttdef"><b>Definition:</b> Polygon_mesh_slicer.h:89</div></div>
<div class="ttc" id="agroup__PMP__repairing__grp_html_ga121f588ac324938d9a6b6931a08661e1"><div class="ttname"><a href="group__PMP__repairing__grp.html#ga121f588ac324938d9a6b6931a08661e1">CGAL::Polygon_mesh_processing::is_non_manifold_vertex</a></div><div class="ttdeci">bool is_non_manifold_vertex(typename boost::graph_traits&lt; PolygonMesh &gt;::vertex_descriptor v, const PolygonMesh &amp;pm)</div><div class="ttdef"><b>Definition:</b> manifoldness.h:50</div></div>
<div class="ttc" id="agroup__hole__filling__grp_html_ga8508fd49a2482ec7dcb3e1799234696a"><div class="ttname"><a href="group__hole__filling__grp.html#ga8508fd49a2482ec7dcb3e1799234696a">CGAL::Polygon_mesh_processing::triangulate_hole_polyline</a></div><div class="ttdeci">OutputIterator triangulate_hole_polyline(const PointRange1 &amp;points, const PointRange2 &amp;third_points, OutputIterator out, const NamedParameters &amp;np)</div><div class="ttdef"><b>Definition:</b> triangulate_hole.h:338</div></div>
<div class="ttc" id="aclassCGAL_1_1AABB__traits_html"><div class="ttname"><a href="../AABB_tree/classCGAL_1_1AABB__traits.html">CGAL::AABB_traits</a></div></div>
<div class="ttc" id="agroup__PMP__meshing__grp_html_gad3d03890515ae8103bd32a30a3486412"><div class="ttname"><a href="group__PMP__meshing__grp.html#gad3d03890515ae8103bd32a30a3486412">CGAL::Polygon_mesh_processing::isotropic_remeshing</a></div><div class="ttdeci">void isotropic_remeshing(const FaceRange &amp;faces, const double &amp;target_edge_length, PolygonMesh &amp;pmesh, const NamedParameters &amp;np)</div><div class="ttdoc">remeshes a triangulated region of a polygon mesh. This operation sequentially performs edge splits,...</div><div class="ttdef"><b>Definition:</b> remesh.h:129</div></div>
<div class="ttc" id="aclassCGAL_1_1Triple_html"><div class="ttname"><a href="../STL_Extension/classCGAL_1_1Triple.html">CGAL::Triple</a></div></div>
<div class="ttc" id="agroup__PkgBGLSelectionFct_html_ga569fe26f889e5e4eed27746ac921651b"><div class="ttname"><a href="../BGL/group__PkgBGLSelectionFct.html#ga569fe26f889e5e4eed27746ac921651b">expand_face_selection</a></div><div class="ttdeci">OutputIterator expand_face_selection(const FaceRange &amp;selection, FaceGraph &amp;fg, unsigned int k, IsFaceSelectedPMap is_selected, OutputIterator out)</div></div>
<div class="ttc" id="aclassCGAL_1_1Cartesian__converter_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Cartesian__converter.html">CGAL::Cartesian_converter</a></div></div>
<div class="ttc" id="agroup__kernel__enums_html_gad0a8110cb95f76bac65649bfe58c650b"><div class="ttname"><a href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a></div><div class="ttdeci">Oriented_side opposite(const Oriented_side &amp;o)</div></div>
<div class="ttc" id="aclassCGAL_1_1Bbox__3_html_a9d06f61bd89faa841e011ff53edf745f"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">CGAL::Bbox_3::ymax</a></div><div class="ttdeci">double ymax() const</div></div>
<div class="ttc" id="aclassCGAL_1_1Bbox__3_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a></div></div>
<div class="ttc" id="agroup__PMP__corefinement__grp_html_gac5a853c33c4b0a9da9403c9b191caa44"><div class="ttname"><a href="group__PMP__corefinement__grp.html#gac5a853c33c4b0a9da9403c9b191caa44">CGAL::Polygon_mesh_processing::corefine_and_compute_difference</a></div><div class="ttdeci">bool corefine_and_compute_difference(TriangleMesh &amp;tm1, TriangleMesh &amp;tm2, TriangleMesh &amp;tm_out, const NamedParameters1 &amp;np1, const NamedParameters2 &amp;np2, const NamedParametersOut &amp;np_out)</div><div class="ttdef"><b>Definition:</b> corefinement.h:572</div></div>
<div class="ttc" id="agroup__PMP__meshing__grp_html_gaa091c8368920920eed87784107d68ecf"><div class="ttname"><a href="group__PMP__meshing__grp.html#gaa091c8368920920eed87784107d68ecf">CGAL::Polygon_mesh_processing::fair</a></div><div class="ttdeci">bool fair(TriangleMesh &amp;tmesh, const VertexRange &amp;vertices, const NamedParameters &amp;np)</div><div class="ttdoc">fairs a region on a triangle mesh. The points of the selected vertices are relocated to yield an as-s...</div><div class="ttdef"><b>Definition:</b> fair.h:106</div></div>
<div class="ttc" id="aclassKernel_1_1Point__3_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Side__of__triangle__mesh_html"><div class="ttname"><a href="classCGAL_1_1Side__of__triangle__mesh.html">CGAL::Side_of_triangle_mesh</a></div><div class="ttdef"><b>Definition:</b> Side_of_triangle_mesh.h:75</div></div>
<div class="ttc" id="agroup__PMP__normal__grp_html_gaa905e5eb07ffeef1433d22a057959cc1"><div class="ttname"><a href="group__PMP__normal__grp.html#gaa905e5eb07ffeef1433d22a057959cc1">CGAL::Polygon_mesh_processing::compute_normals</a></div><div class="ttdeci">void compute_normals(const PolygonMesh &amp;pmesh, VertexNormalMap vertex_normals, FaceNormalMap face_normals, const NamedParameters &amp;np)</div><div class="ttdef"><b>Definition:</b> compute_normal.h:820</div></div>
<div class="ttc" id="astructCGAL_1_1Face__filtered__graph_html"><div class="ttname"><a href="../BGL/structCGAL_1_1Face__filtered__graph.html">CGAL::Face_filtered_graph</a></div></div>
<div class="ttc" id="aclassKernel_html_a00792fd1a5d950d54a750f4aa9d2ba3f"><div class="ttname"><a href="../Kernel_23/classKernel.html#a00792fd1a5d950d54a750f4aa9d2ba3f">Kernel::Compare_dihedral_angle_3</a></div><div class="ttdeci">unspecified_type Compare_dihedral_angle_3</div></div>
<div class="ttc" id="agroup__kernel__enums_html_ga4a98ec6bd9dfd8fe8c46fea553b5d238"><div class="ttname"><a href="../Kernel_23/group__kernel__enums.html#ga4a98ec6bd9dfd8fe8c46fea553b5d238">NULL_VECTOR</a></div><div class="ttdeci">const CGAL::Null_vector NULL_VECTOR</div></div>
<div class="ttc" id="agroup__keep__connected__components__grp_html_ga68c6c29dfc6a26a6a2f8befe6944f19d"><div class="ttname"><a href="group__keep__connected__components__grp.html#ga68c6c29dfc6a26a6a2f8befe6944f19d">CGAL::Polygon_mesh_processing::keep_largest_connected_components</a></div><div class="ttdeci">std::size_t keep_largest_connected_components(PolygonMesh &amp;pmesh, std::size_t nb_components_to_keep, const NamedParameters &amp;np)</div><div class="ttdef"><b>Definition:</b> connected_components.h:359</div></div>
<div class="ttc" id="agroup__PMP__distance__grp_html_ga2b28867dc150931b2f12d17b77d15266"><div class="ttname"><a href="group__PMP__distance__grp.html#ga2b28867dc150931b2f12d17b77d15266">CGAL::Polygon_mesh_processing::approximate_Hausdorff_distance</a></div><div class="ttdeci">double approximate_Hausdorff_distance(const TriangleMesh &amp;tm1, const TriangleMesh &amp;tm2, const NamedParameters1 &amp;np1, const NamedParameters2 &amp;np2)</div><div class="ttdef"><b>Definition:</b> distance.h:1033</div></div>
<div class="ttc" id="agroup__kernel__enums_html_gaf6030e89dadcc1f45369b0cdc5d9e111"><div class="ttname"><a href="../Kernel_23/group__kernel__enums.html#gaf6030e89dadcc1f45369b0cdc5d9e111">CGAL::Bounded_side</a></div><div class="ttdeci">Bounded_side</div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_ga11883d231eec1b58f37efe4acedd9588"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">is_triangle_mesh</a></div><div class="ttdeci">bool is_triangle_mesh(const FaceGraph &amp;g)</div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_gae04c8044cf1eee6a84baa5b79ab99fef"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#gae04c8044cf1eee6a84baa5b79ab99fef">is_closed</a></div><div class="ttdeci">bool is_closed(const FaceGraph &amp;g)</div></div>
<div class="ttc" id="anamespaceKernel_html"><div class="ttname"><a href="../Kernel_23/namespaceKernel.html">Kernel</a></div></div>
<div class="ttc" id="agroup__PMP__orientation__grp_html_gae25c1198a89c53d5df2f29dd57fda5ca"><div class="ttname"><a href="group__PMP__orientation__grp.html#gae25c1198a89c53d5df2f29dd57fda5ca">CGAL::Polygon_mesh_processing::merge_reversible_connected_components</a></div><div class="ttdeci">void merge_reversible_connected_components(PolygonMesh &amp;pm, const NamedParameters &amp;np)</div><div class="ttdef"><b>Definition:</b> orientation.h:1372</div></div>
<div class="ttc" id="aclassCGAL_1_1Bbox__3_html_a6c55430abc7fda54571cf1075c7f2f8b"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">CGAL::Bbox_3::zmin</a></div><div class="ttdeci">double zmin() const</div></div>
<div class="ttc" id="agroup__PMP__corefinement__grp_html_gad7e1741a7ce41a5846cf86494982ca8b"><div class="ttname"><a href="group__PMP__corefinement__grp.html#gad7e1741a7ce41a5846cf86494982ca8b">CGAL::Polygon_mesh_processing::corefine_and_compute_union</a></div><div class="ttdeci">bool corefine_and_compute_union(TriangleMesh &amp;tm1, TriangleMesh &amp;tm2, TriangleMesh &amp;tm_out, const NamedParameters1 &amp;np1, const NamedParameters2 &amp;np2, const NamedParametersOut &amp;np_out)</div><div class="ttdef"><b>Definition:</b> corefinement.h:508</div></div>
<div class="ttc" id="agroup__keep__connected__components__grp_html_gad2546bc14c00bac66d87161a4044f871"><div class="ttname"><a href="group__keep__connected__components__grp.html#gad2546bc14c00bac66d87161a4044f871">CGAL::Polygon_mesh_processing::connected_component</a></div><div class="ttdeci">FaceOutputIterator connected_component(typename boost::graph_traits&lt; PolygonMesh &gt;::face_descriptor seed_face, const PolygonMesh &amp;pmesh, FaceOutputIterator out, const NamedParameters &amp;np)</div><div class="ttdef"><b>Definition:</b> connected_components.h:125</div></div>
<div class="ttc" id="aclassCGAL_1_1AABB__tree_html"><div class="ttname"><a href="../AABB_tree/classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Random__points__in__cube__3_html"><div class="ttname"><a href="../Generator/classCGAL_1_1Random__points__in__cube__3.html">CGAL::Random_points_in_cube_3</a></div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_gad2e132763721d8e4fd22020c1665c15f"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#gad2e132763721d8e4fd22020c1665c15f">make_tetrahedron</a></div><div class="ttdeci">boost::graph_traits&lt; Graph &gt;::halfedge_descriptor make_tetrahedron(const P &amp;p0, const P &amp;p1, const P &amp;p2, const P &amp;p3, Graph &amp;g)</div></div>
<div class="ttc" id="agroup__PMP__repairing__grp_html_ga8ae4352e67d2b099994ac8990c13bd41"><div class="ttname"><a href="group__PMP__repairing__grp.html#ga8ae4352e67d2b099994ac8990c13bd41">CGAL::Polygon_mesh_processing::stitch_borders</a></div><div class="ttdeci">std::size_t stitch_borders(PolygonMesh &amp;pmesh, const HalfedgePairsRange &amp;hedge_pairs_to_stitch)</div><div class="ttdef"><b>Definition:</b> stitch_borders.h:843</div></div>
<div class="ttc" id="agroup__PMP__orientation__grp_html_ga2aa4f7b500dc51d1fc4747705a050946"><div class="ttname"><a href="group__PMP__orientation__grp.html#ga2aa4f7b500dc51d1fc4747705a050946">CGAL::Polygon_mesh_processing::duplicate_non_manifold_edges_in_polygon_soup</a></div><div class="ttdeci">bool duplicate_non_manifold_edges_in_polygon_soup(PointRange &amp;points, PolygonRange &amp;polygons)</div><div class="ttdef"><b>Definition:</b> orient_polygon_soup_extension.h:60</div></div>
<div class="ttc" id="aclassCGAL_1_1Polyhedron__3_html"><div class="ttname"><a href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3</a></div></div>
<div class="ttc" id="agroup__PMP__detect__features__grp_html_ga1daa8515d6867e977c470a53dfb93838"><div class="ttname"><a href="group__PMP__detect__features__grp.html#ga1daa8515d6867e977c470a53dfb93838">CGAL::Polygon_mesh_processing::sharp_edges_segmentation</a></div><div class="ttdeci">boost::graph_traits&lt; PolygonMesh &gt;::faces_size_type sharp_edges_segmentation(PolygonMesh &amp;pmesh, FT angle_in_deg, EdgeIsFeatureMap edge_is_feature_map, PatchIdMap patch_id_map, const NamedParameters &amp;np)</div><div class="ttdef"><b>Definition:</b> detect_features.h:411</div></div>
<div class="ttc" id="agroup__PMP__meshing__grp_html_gaafd017f4424c3942bfdcc93874c8f596"><div class="ttname"><a href="group__PMP__meshing__grp.html#gaafd017f4424c3942bfdcc93874c8f596">CGAL::Polygon_mesh_processing::split_long_edges</a></div><div class="ttdeci">void split_long_edges(const EdgeRange &amp;edges, const double &amp;max_length, PolygonMesh &amp;pmesh, const NamedParameters &amp;np)</div><div class="ttdoc">splits the edges listed in edges into sub-edges that are not longer than the given threshold max_leng...</div><div class="ttdef"><b>Definition:</b> remesh.h:321</div></div>
<div class="ttc" id="agroup__PMP__orientation__grp_html_gaadc5bac3072b11d2313e40043c729d0a"><div class="ttname"><a href="group__PMP__orientation__grp.html#gaadc5bac3072b11d2313e40043c729d0a">CGAL::Polygon_mesh_processing::orient_polygon_soup</a></div><div class="ttdeci">bool orient_polygon_soup(PointRange &amp;points, PolygonRange &amp;polygons)</div><div class="ttdef"><b>Definition:</b> orient_polygon_soup.h:473</div></div>
<div class="ttc" id="agroup__PMP__repairing__grp_html_ga8b9d12d817b5cc76f5a42d74eac75bf3"><div class="ttname"><a href="group__PMP__repairing__grp.html#ga8b9d12d817b5cc76f5a42d74eac75bf3">CGAL::Polygon_mesh_processing::is_polygon_soup_a_polygon_mesh</a></div><div class="ttdeci">bool is_polygon_soup_a_polygon_mesh(const PolygonRange &amp;polygons)</div><div class="ttdef"><b>Definition:</b> polygon_soup_to_polygon_mesh.h:157</div></div>
<div class="ttc" id="agroup__keep__connected__components__grp_html_ga48e7b3e6922ee78cf8ce801e3e325d9a"><div class="ttname"><a href="group__keep__connected__components__grp.html#ga48e7b3e6922ee78cf8ce801e3e325d9a">CGAL::Polygon_mesh_processing::keep_large_connected_components</a></div><div class="ttdeci">std::size_t keep_large_connected_components(PolygonMesh &amp;pmesh, const ThresholdValueType threshold_value, const NamedParameters &amp;np)</div><div class="ttdef"><b>Definition:</b> connected_components.h:490</div></div>
<div class="ttc" id="aclassCGAL_1_1Bbox__3_html_a98def8b9515f31ded759d781969ddaf6"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">CGAL::Bbox_3::zmax</a></div><div class="ttdeci">double zmax() const</div></div>
<div class="ttc" id="agroup__PMP__orientation__grp_html_gafdbc256d06536f6aca2558bc1a0156e2"><div class="ttname"><a href="group__PMP__orientation__grp.html#gafdbc256d06536f6aca2558bc1a0156e2">CGAL::Polygon_mesh_processing::orient_to_bound_a_volume</a></div><div class="ttdeci">void orient_to_bound_a_volume(TriangleMesh &amp;tm, const NamedParameters &amp;np)</div><div class="ttdef"><b>Definition:</b> orientation.h:1275</div></div>
<div class="ttc" id="agroup__keep__connected__components__grp_html_gabe2052b2281e1e628e68d8fea94be2d9"><div class="ttname"><a href="group__keep__connected__components__grp.html#gabe2052b2281e1e628e68d8fea94be2d9">CGAL::Polygon_mesh_processing::connected_components</a></div><div class="ttdeci">boost::property_traits&lt; FaceComponentMap &gt;::value_type connected_components(const PolygonMesh &amp;pmesh, FaceComponentMap fcm, const NamedParameters &amp;np)</div><div class="ttdef"><b>Definition:</b> connected_components.h:202</div></div>
<div class="ttc" id="aclassCGAL_1_1AABB__halfedge__graph__segment__primitive_html"><div class="ttname"><a href="../AABB_tree/classCGAL_1_1AABB__halfedge__graph__segment__primitive.html">CGAL::AABB_halfedge_graph_segment_primitive</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Bbox__3_html_a3f5e323700e1509624a02d151237cc4c"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">CGAL::Bbox_3::xmax</a></div><div class="ttdeci">double xmax() const</div></div>
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__exact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a></div></div>
<div class="ttc" id="astructCGAL_1_1Property__map__to__unary__function_html"><div class="ttname"><a href="../Property_map/structCGAL_1_1Property__map__to__unary__function.html">CGAL::Property_map_to_unary_function</a></div></div>
<div class="ttc" id="agroup__PkgPolygonMeshProcessingRef_html_gafa9b682528c5dc2a4821d01193518d14"><div class="ttname"><a href="group__PkgPolygonMeshProcessingRef.html#gafa9b682528c5dc2a4821d01193518d14">CGAL::Polygon_mesh_processing::extract_boundary_cycles</a></div><div class="ttdeci">OutputIterator extract_boundary_cycles(PolygonMesh &amp;pm, OutputIterator out)</div><div class="ttdef"><b>Definition:</b> border.h:255</div></div>
<div class="ttc" id="aclassCGAL_1_1Bbox__3_html_aab574470a2591f187553ca1166e682e1"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">CGAL::Bbox_3::xmin</a></div><div class="ttdeci">double xmin() const</div></div>
<div class="ttc" id="agroup__PkgPolygonMeshProcessingRef_html_ga6f02a9031838b5b3436128d9ac3da26e"><div class="ttname"><a href="group__PkgPolygonMeshProcessingRef.html#ga6f02a9031838b5b3436128d9ac3da26e">CGAL::Polygon_mesh_processing::border_halfedges</a></div><div class="ttdeci">HalfedgeOutputIterator border_halfedges(const FaceRange &amp;face_range, const PolygonMesh &amp;pmesh, HalfedgeOutputIterator out, const NamedParameters &amp;np)</div><div class="ttdef"><b>Definition:</b> border.h:176</div></div>
<div class="ttc" id="agroup__PkgBGLIterators_html_ga2be4fd4d24b1e48e00a92f90f0f2923c"><div class="ttname"><a href="../BGL/group__PkgBGLIterators.html#ga2be4fd4d24b1e48e00a92f90f0f2923c">halfedges_around_target</a></div><div class="ttdeci">Iterator_range&lt; Halfedge_around_target_iterator&lt; Graph &gt; &gt; halfedges_around_target(typename boost::graph_traits&lt; Graph &gt;::halfedge_descriptor h, const Graph &amp;g)</div></div>
<div class="ttc" id="agroup__PMP__meshing__grp_html_gacaaff4d520500c530d9c3d5ebe2a0760"><div class="ttname"><a href="group__PMP__meshing__grp.html#gacaaff4d520500c530d9c3d5ebe2a0760">CGAL::Polygon_mesh_processing::triangulate_faces</a></div><div class="ttdeci">bool triangulate_faces(FaceRange face_range, PolygonMesh &amp;pmesh, const NamedParameters &amp;np)</div><div class="ttdef"><b>Definition:</b> triangulate_faces.h:475</div></div>
<div class="ttc" id="aclassCGAL_1_1Bbox__3_html_a2088e16a1f0a20e011e5b94c2e9c222a"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">CGAL::Bbox_3::ymin</a></div><div class="ttdeci">double ymin() const</div></div>
<div class="ttc" id="agroup__kernel__enums_html_gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b"><div class="ttname"><a href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b">SMALLER</a></div><div class="ttdeci">SMALLER</div></div>
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</div>
</body>
</html>
