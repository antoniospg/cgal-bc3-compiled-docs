<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CGAL 5.1 - Polygon Mesh Processing: Orientation Functions</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
      }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png"
           onmouseover="return searchBox.OnSearchSelectShow()"
           onmouseout="return searchBox.OnSearchSelectHide()"
           alt=""/>
      <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)"
             onblur="searchBox.OnSearchFieldFocus(false)"
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt=""/></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.1 - Polygon Mesh Processing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__PMP__orientation__grp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Orientation Functions<div class="ingroups"><a class="el" href="group__PkgPolygonMeshProcessingRef.html">Polygon Mesh Processing Reference</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<p>Functions to compute or change the orientation of faces and surfaces. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga0cc8819f7a6e09086a9381fa29918d48"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PMP__orientation__grp.html#ga0cc8819f7a6e09086a9381fa29918d48">CGAL::Polygon_mesh_processing::Volume_error_code</a> { <a class="el" href="group__PMP__orientation__grp.html#gga0cc8819f7a6e09086a9381fa29918d48ab0b5c051e298e25b83338c5e7b3a4704">CGAL::Polygon_mesh_processing::VALID_VOLUME</a>, 
<a class="el" href="group__PMP__orientation__grp.html#gga0cc8819f7a6e09086a9381fa29918d48ad9e462d2dfe21137aa9dfb56e0a8d067">CGAL::Polygon_mesh_processing::SURFACE_WITH_SELF_INTERSECTIONS</a>, 
<a class="el" href="group__PMP__orientation__grp.html#gga0cc8819f7a6e09086a9381fa29918d48a421e502b1cb8f48d1f9f3e84a046c31d">CGAL::Polygon_mesh_processing::VOLUME_INTERSECTION</a>, 
<a class="el" href="group__PMP__orientation__grp.html#gga0cc8819f7a6e09086a9381fa29918d48a7c11c1c20f8917e666b1fa936d0571f1">CGAL::Polygon_mesh_processing::INCOMPATIBLE_ORIENTATION</a>
 }</td></tr>
<tr class="separator:ga0cc8819f7a6e09086a9381fa29918d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaadc5bac3072b11d2313e40043c729d0a"><td class="memTemplParams" colspan="2">template&lt;class PointRange , class PolygonRange &gt; </td></tr>
<tr class="memitem:gaadc5bac3072b11d2313e40043c729d0a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__orientation__grp.html#gaadc5bac3072b11d2313e40043c729d0a">CGAL::Polygon_mesh_processing::orient_polygon_soup</a> (PointRange &amp;points, PolygonRange &amp;polygons)</td></tr>
<tr class="separator:gaadc5bac3072b11d2313e40043c729d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa4f7b500dc51d1fc4747705a050946"><td class="memTemplParams" colspan="2">template&lt;class PointRange , class PolygonRange &gt; </td></tr>
<tr class="memitem:ga2aa4f7b500dc51d1fc4747705a050946"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__orientation__grp.html#ga2aa4f7b500dc51d1fc4747705a050946">CGAL::Polygon_mesh_processing::duplicate_non_manifold_edges_in_polygon_soup</a> (PointRange &amp;points, PolygonRange &amp;polygons)</td></tr>
<tr class="separator:ga2aa4f7b500dc51d1fc4747705a050946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31779672b3afd660664fc9a6c4fdf74d"><td class="memTemplParams" colspan="2">template&lt;class Concurrency_tag  = Sequential_tag, class PointRange , class TriangleRange , class TriangleMesh , class NamedParameters &gt; </td></tr>
<tr class="memitem:ga31779672b3afd660664fc9a6c4fdf74d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__orientation__grp.html#ga31779672b3afd660664fc9a6c4fdf74d">CGAL::Polygon_mesh_processing::orient_triangle_soup_with_reference_triangle_mesh</a> (const TriangleMesh &amp;tm_ref, PointRange &amp;points, TriangleRange &amp;triangles, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga31779672b3afd660664fc9a6c4fdf74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53a77073bf9a4118ecf949b851e1f5d9"><td class="memTemplParams" colspan="2">template&lt;typename TriangleMesh , typename NamedParameters &gt; </td></tr>
<tr class="memitem:ga53a77073bf9a4118ecf949b851e1f5d9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__orientation__grp.html#ga53a77073bf9a4118ecf949b851e1f5d9">CGAL::Polygon_mesh_processing::is_outward_oriented</a> (const TriangleMesh &amp;tm, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga53a77073bf9a4118ecf949b851e1f5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8a3439883e3e76651f96d15ba58b2bc"><td class="memTemplParams" colspan="2">template&lt;typename PolygonMesh &gt; </td></tr>
<tr class="memitem:gad8a3439883e3e76651f96d15ba58b2bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__orientation__grp.html#gad8a3439883e3e76651f96d15ba58b2bc">CGAL::Polygon_mesh_processing::reverse_face_orientations</a> (PolygonMesh &amp;pmesh)</td></tr>
<tr class="separator:gad8a3439883e3e76651f96d15ba58b2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21119757bf5835496ae1c9a6d4f5fa0a"><td class="memTemplParams" colspan="2">template&lt;typename PolygonMesh , typename FaceRange &gt; </td></tr>
<tr class="memitem:ga21119757bf5835496ae1c9a6d4f5fa0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__orientation__grp.html#ga21119757bf5835496ae1c9a6d4f5fa0a">CGAL::Polygon_mesh_processing::reverse_face_orientations</a> (const FaceRange &amp;face_range, PolygonMesh &amp;pmesh)</td></tr>
<tr class="separator:ga21119757bf5835496ae1c9a6d4f5fa0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe035adcc4ff061b4438cc9dae591d00"><td class="memTemplParams" colspan="2">template&lt;class TriangleMesh , class NamedParameters &gt; </td></tr>
<tr class="memitem:gafe035adcc4ff061b4438cc9dae591d00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__orientation__grp.html#gafe035adcc4ff061b4438cc9dae591d00">CGAL::Polygon_mesh_processing::orient</a> (TriangleMesh &amp;tm, const NamedParameters &amp;np)</td></tr>
<tr class="separator:gafe035adcc4ff061b4438cc9dae591d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga133e58280959c152770525f27bb42b91"><td class="memTemplParams" colspan="2">template&lt;class TriangleMesh , class VolumeFaceIndexMap , class NamedParameters &gt; </td></tr>
<tr class="memitem:ga133e58280959c152770525f27bb42b91"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__orientation__grp.html#ga133e58280959c152770525f27bb42b91">CGAL::Polygon_mesh_processing::volume_connected_components</a> (const TriangleMesh &amp;tm, VolumeFaceIndexMap volume_id_map, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga133e58280959c152770525f27bb42b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga808a0177bf30833d2c1e390e533fec7f"><td class="memTemplParams" colspan="2">template&lt;class TriangleMesh , class NamedParameters &gt; </td></tr>
<tr class="memitem:ga808a0177bf30833d2c1e390e533fec7f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__orientation__grp.html#ga808a0177bf30833d2c1e390e533fec7f">CGAL::Polygon_mesh_processing::does_bound_a_volume</a> (const TriangleMesh &amp;tm, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga808a0177bf30833d2c1e390e533fec7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbc256d06536f6aca2558bc1a0156e2"><td class="memTemplParams" colspan="2">template&lt;class TriangleMesh , class NamedParameters &gt; </td></tr>
<tr class="memitem:gafdbc256d06536f6aca2558bc1a0156e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__orientation__grp.html#gafdbc256d06536f6aca2558bc1a0156e2">CGAL::Polygon_mesh_processing::orient_to_bound_a_volume</a> (TriangleMesh &amp;tm, const NamedParameters &amp;np)</td></tr>
<tr class="separator:gafdbc256d06536f6aca2558bc1a0156e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae25c1198a89c53d5df2f29dd57fda5ca"><td class="memTemplParams" colspan="2">template&lt;class PolygonMesh , class NamedParameters &gt; </td></tr>
<tr class="memitem:gae25c1198a89c53d5df2f29dd57fda5ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__orientation__grp.html#gae25c1198a89c53d5df2f29dd57fda5ca">CGAL::Polygon_mesh_processing::merge_reversible_connected_components</a> (PolygonMesh &amp;pm, const NamedParameters &amp;np)</td></tr>
<tr class="separator:gae25c1198a89c53d5df2f29dd57fda5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga0cc8819f7a6e09086a9381fa29918d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cc8819f7a6e09086a9381fa29918d48">&#9670;&nbsp;</a></span>Volume_error_code</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PMP__orientation__grp.html#ga0cc8819f7a6e09086a9381fa29918d48">CGAL::Polygon_mesh_processing::Volume_error_code</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/orientation.h&gt;</code></p>
<p>Enumeration type used to indicate the status of a set of faces classified by the function <code><a class="el" href="group__PMP__orientation__grp.html#ga133e58280959c152770525f27bb42b91">volume_connected_components()</a></code>. The set of faces defines either a volume connected connected component in the case of <code>VALID_VOLUME</code> or a surface connected component otherwise. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0cc8819f7a6e09086a9381fa29918d48ab0b5c051e298e25b83338c5e7b3a4704"></a>VALID_VOLUME&#160;</td><td class="fielddoc"><p>The set of faces bounds a volume. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0cc8819f7a6e09086a9381fa29918d48ad9e462d2dfe21137aa9dfb56e0a8d067"></a>SURFACE_WITH_SELF_INTERSECTIONS&#160;</td><td class="fielddoc"><p>The set of faces is self-intersecting. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0cc8819f7a6e09086a9381fa29918d48a421e502b1cb8f48d1f9f3e84a046c31d"></a>VOLUME_INTERSECTION&#160;</td><td class="fielddoc"><p>The set of faces intersects another surface connected component. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0cc8819f7a6e09086a9381fa29918d48a7c11c1c20f8917e666b1fa936d0571f1"></a>INCOMPATIBLE_ORIENTATION&#160;</td><td class="fielddoc"><p>The set of faces is included in a volume but has an incompatible orientation. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga808a0177bf30833d2c1e390e533fec7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga808a0177bf30833d2c1e390e533fec7f">&#9670;&nbsp;</a></span>does_bound_a_volume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TriangleMesh , class NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::Polygon_mesh_processing::does_bound_a_volume </td>
          <td>(</td>
          <td class="paramtype">const TriangleMesh &amp;&#160;</td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/orientation.h&gt;</code></p>
<p>indicates if <code>tm</code> bounds a volume. See <a class="el" href="index.html#coref_def_subsec">Definitions</a> for details.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code>, <code><a class="elRef" href="../BGL/classHalfedgeListGraph.html">HalfedgeListGraph</a></code> and <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code>. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__pmp__namedparameters.html">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>a closed triangulated surface mesh </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__pmp__namedparameters.html">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>CGAL::is_closed(tm)</code></dd></dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_vertex_point_map">vertex_point_map</a></td><td>the property map with the points associated to the vertices of <code>tm</code>. If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> must be available in <code>TriangleMesh</code>  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_face_index_map">face_index_map</a></td><td>a property map containing the index of each face of <code>tm</code>.  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_is_cc_outward_oriented">is_cc_outward_oriented</a></td><td>a <code>reference_wrapper</code> (either from <code>boost</code> or the standard library) containing a reference to an object of type <code>std::vector&lt;bool&gt;</code>. The size of the vector is exactly the number of connected components. For each connected component identified using its id <code>ccid</code>, the output of <code>is_outward_oriented</code> called on the submesh corresponding to this connected component is the value at the position <code>ccid</code> in the parameter vector.  </td></tr>
</table>
</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PMP__orientation__grp.html#gafdbc256d06536f6aca2558bc1a0156e2">CGAL::Polygon_mesh_processing::orient_to_bound_a_volume()</a></code> </dd></dl>

</div>
</div>
<a id="ga2aa4f7b500dc51d1fc4747705a050946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2aa4f7b500dc51d1fc4747705a050946">&#9670;&nbsp;</a></span>duplicate_non_manifold_edges_in_polygon_soup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointRange , class PolygonRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::Polygon_mesh_processing::duplicate_non_manifold_edges_in_polygon_soup </td>
          <td>(</td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PolygonRange &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/orient_polygon_soup_extension.h&gt;</code></p>
<p>duplicates each point <em>p</em> at which the intersection of an infinitesimally small ball centered at <em>p</em> with the polygons incident to it is not a topological disk.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>a model of the concepts <code>RandomAccessContainer</code> and <code>BackInsertionSequence</code> whose <code>value_type</code> is the point type. </td></tr>
    <tr><td class="paramname">PolygonRange</td><td>a model of the concept <code>RandomAccessContainer</code> whose <code>value_type</code> is a model of the concept <code>RandomAccessContainer</code> whose <code>value_type</code> is <code>std::size_t</code>, and is also a model of <code>BackInsertionSequence</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>points of the soup of polygons. Some additional points might be pushed back to resolve non-manifoldness or non-orientability issues. </td></tr>
    <tr><td class="paramname">polygons</td><td>each element in the vector describes a polygon using the indices of the points in <code>points</code>. If needed the order of the indices of a polygon might be reversed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if some points were duplicated, thus producing a self-intersecting surface mesh. </dd>
<dd>
<code>true</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PMP__orientation__grp.html#gaadc5bac3072b11d2313e40043c729d0a">orient_polygon_soup()</a></code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Polygon_mesh_processing_2orientation_pipeline_example_8cpp-example.html#a3">Polygon_mesh_processing/orientation_pipeline_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga53a77073bf9a4118ecf949b851e1f5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53a77073bf9a4118ecf949b851e1f5d9">&#9670;&nbsp;</a></span>is_outward_oriented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TriangleMesh , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::Polygon_mesh_processing::is_outward_oriented </td>
          <td>(</td>
          <td class="paramtype">const TriangleMesh &amp;&#160;</td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/orientation.h&gt;</code></p>
<p>tests whether a closed triangle mesh has a positive orientation. A closed triangle mesh is considered to have a positive orientation if the normal vectors to all its faces point outside the domain bounded by the triangle mesh. The normal vector to each face is chosen pointing on the side of the face where its sequence of vertices is seen counterclockwise. </p><dl class="section pre"><dt>Precondition</dt><dd><code>CGAL::is_closed(tm)</code> </dd>
<dd>
<code>CGAL::is_triangle_mesh(tm)</code> </dd>
<dd>
If <code>tm</code> contains several connected components, they are oriented consistently. In other words, the answer to this predicate would be the same for each isolated connected component.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__pmp__namedparameters.html">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>the closed triangle mesh free from self-intersections to be tested </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__pmp__namedparameters.html">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_vertex_point_map">vertex_point_map</a></td><td>the property map with the points associated to the vertices of <code>tm</code> If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> must be available in <code>TriangleMesh</code>  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_geom_traits">geom_traits</a></td><td>a geometric traits class instance  </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is only doing an orientation test for one connected component of <code>tm</code>. For performance reasons, it is left to the user to call the function <code><a class="el" href="group__PMP__orientation__grp.html#ga808a0177bf30833d2c1e390e533fec7f">does_bound_a_volume()</a></code> on a triangulated version of <code>tm</code> to ensure the result returned is relevant. For advanced usages, the function <code><a class="el" href="group__PMP__orientation__grp.html#ga133e58280959c152770525f27bb42b91">volume_connected_components()</a></code> should be used instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PMP__orientation__grp.html#ga21119757bf5835496ae1c9a6d4f5fa0a">CGAL::Polygon_mesh_processing::reverse_face_orientations()</a></code> </dd></dl>

</div>
</div>
<a id="gae25c1198a89c53d5df2f29dd57fda5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae25c1198a89c53d5df2f29dd57fda5ca">&#9670;&nbsp;</a></span>merge_reversible_connected_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolygonMesh , class NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::Polygon_mesh_processing::merge_reversible_connected_components </td>
          <td>(</td>
          <td class="paramtype">PolygonMesh &amp;&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/orientation.h&gt;</code></p>
<p>reverses the connected components of <code>tm</code> having compatible boundary cycles that could be merged if their orientation were made compatible, and stitches them. Connected components are examined by increasing number of faces.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolygonMesh</td><td>a model of <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code>, <code><a class="elRef" href="../BGL/classHalfedgeListGraph.html">HalfedgeListGraph</a></code> and <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code>. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__pmp__namedparameters.html">Named Parameters for Polygon Mesh Processing</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>a surface mesh </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__pmp__namedparameters.html">Named Parameters for Polygon Mesh Processing</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_vertex_point_map">vertex_point_map</a></td><td>the property map with the points associated to the vertices of <code>pm</code>. If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> must be available in <code>PolygonMesh</code>  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_face_index_map">face_index_map</a></td><td>a property map containing an index for each face initialized from 0 to num_faces(pm).  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_maximum_number_of_faces">maximum_number_of_faces</a></td><td>if not 0 (default), a connected component is considered reversible only if it has no more faces than the value given. Otherwise, it is always considered reversible.  </td></tr>
</table>
</dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Polygon_mesh_processing_2orientation_pipeline_example_8cpp-example.html#a7">Polygon_mesh_processing/orientation_pipeline_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gafe035adcc4ff061b4438cc9dae591d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe035adcc4ff061b4438cc9dae591d00">&#9670;&nbsp;</a></span>orient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TriangleMesh , class NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::Polygon_mesh_processing::orient </td>
          <td>(</td>
          <td class="paramtype">TriangleMesh &amp;&#160;</td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/orientation.h&gt;</code></p>
<p>makes each connected component of a closed triangulated surface mesh inward or outward oriented.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> and <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> . </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__pmp__namedparameters.html">Named Parameters for Polygon Mesh Processing</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>a closed triangulated surface mesh </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__pmp__namedparameters.html">Named Parameters for Polygon Mesh Processing</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>CGAL::is_closed(tm)</code></dd></dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_vertex_point_map">vertex_point_map</a></td><td>the property map with the points associated to the vertices of <code>tm</code>. If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> must be available in <code>TriangleMesh</code>  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_face_index_map">face_index_map</a></td><td>a property map containing the index of each face of <code>tm</code>.  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_outward_orientation">outward_orientation</a></td><td>if set to <code>true</code> (default) indicates that each connected component will be outward oriented, (inward oriented if <code>false</code>).  </td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a id="gaadc5bac3072b11d2313e40043c729d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadc5bac3072b11d2313e40043c729d0a">&#9670;&nbsp;</a></span>orient_polygon_soup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointRange , class PolygonRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::Polygon_mesh_processing::orient_polygon_soup </td>
          <td>(</td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PolygonRange &amp;&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/orient_polygon_soup.h&gt;</code></p>
<p>tries to consistently orient a soup of polygons in 3D space. When it is not possible to produce a combinatorial manifold surface, some points are duplicated. Because a polygon soup does not have any connectivity (each point has as many occurrences as the number of polygons it belongs to), duplicating one point (or a pair of points) amounts to duplicate the polygon to which it belongs.</p>
<p>These points are either an endpoint of an edge incident to more than two polygons, an endpoint of an edge between two polygons with incompatible orientations (during the re-orientation process), or more generally a point <em>p</em> at which the intersection of an infinitesimally small ball centered at <em>p</em> with the polygons incident to it is not a topological disk.</p>
<p>The algorithm is described in <a class="el" href="citelist.html#CITEREF_gueziec2001cutting">[1]</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>a model of the concepts <code>RandomAccessContainer</code> and <code>BackInsertionSequence</code> whose value type is the point type. </td></tr>
    <tr><td class="paramname">PolygonRange</td><td>a model of the concept <code>RandomAccessContainer</code> whose value_type is a model of the concept <code>RandomAccessContainer</code> whose value_type is <code>std::size_t</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>points of the soup of polygons. Some additional points might be pushed back to resolve non-manifoldness or non-orientability issues. </td></tr>
    <tr><td class="paramname">polygons</td><td>each element in the vector describes a polygon using the index of the points in <code>points</code>. If needed the order of the indices of a polygon might be reversed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the orientation operation succeded. </dd>
<dd>
<code>false</code> if some points were duplicated, thus producing a self-intersecting polyhedron. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Polygon_mesh_processing_2orient_polygon_soup_example_8cpp-example.html#a2">Polygon_mesh_processing/orient_polygon_soup_example.cpp</a>, and <a class="el" href="Polygon_mesh_processing_2repair_polygon_soup_example_8cpp-example.html#a3">Polygon_mesh_processing/repair_polygon_soup_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gafdbc256d06536f6aca2558bc1a0156e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdbc256d06536f6aca2558bc1a0156e2">&#9670;&nbsp;</a></span>orient_to_bound_a_volume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TriangleMesh , class NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::Polygon_mesh_processing::orient_to_bound_a_volume </td>
          <td>(</td>
          <td class="paramtype">TriangleMesh &amp;&#160;</td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/orientation.h&gt;</code></p>
<p>orients the connected components of <code>tm</code> to make it bound a volume. See <a class="el" href="index.html#coref_def_subsec">Definitions</a> for a precise definition.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code>, <code><a class="elRef" href="../BGL/classHalfedgeListGraph.html">HalfedgeListGraph</a></code> and <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code>. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__pmp__namedparameters.html">Named Parameters for Polygon Mesh Processing</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>a closed triangulated surface mesh </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__pmp__namedparameters.html">Named Parameters for Polygon Mesh Processing</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>CGAL::is_closed(tm)</code></dd></dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_vertex_point_map">vertex_point_map</a></td><td>the property map with the points associated to the vertices of <code>tm</code>. If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> must be available in <code>TriangleMesh</code>  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_face_index_map">face_index_map</a></td><td>a property map containing the index of each face of <code>tm</code>.  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_outward_orientation">outward_orientation</a></td><td>if set to <code>true</code> (default) the outer connected components will be outward oriented (inward oriented if set to <code>false</code>). If the outer connected components are inward oriented, it means that the infinity will be considered as part of the volume bounded by <code>tm</code>.  </td></tr>
</table>
</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PMP__orientation__grp.html#ga808a0177bf30833d2c1e390e533fec7f">CGAL::Polygon_mesh_processing::does_bound_a_volume()</a></code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Polygon_mesh_processing_2orient_polygon_soup_example_8cpp-example.html#a5">Polygon_mesh_processing/orient_polygon_soup_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga31779672b3afd660664fc9a6c4fdf74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31779672b3afd660664fc9a6c4fdf74d">&#9670;&nbsp;</a></span>orient_triangle_soup_with_reference_triangle_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Concurrency_tag  = Sequential_tag, class PointRange , class TriangleRange , class TriangleMesh , class NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::Polygon_mesh_processing::orient_triangle_soup_with_reference_triangle_mesh </td>
          <td>(</td>
          <td class="paramtype">const TriangleMesh &amp;&#160;</td>
          <td class="paramname"><em>tm_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TriangleRange &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/orient_polygon_soup_extension.h&gt;</code></p>
<p>orients each triangle of a triangle soup using the orientation of its closest non degenerate triangle in <code>tm_ref</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Concurrency_tag</td><td>enables sequential versus parallel orientation. Possible values are <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a></code> (the default), <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">Parallel_if_available_tag</a></code>, and <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a></code>. </td></tr>
    <tr><td class="paramname">PointRange</td><td>a model of the concepts <code>RandomAccessContainer</code> and <code>BackInsertionSequence</code> whose value type is the point type. </td></tr>
    <tr><td class="paramname">TriangleRange</td><td>a model of the concept <code>RandomAccessContainer</code> whose <code>value_type</code> is a model of the concept <code>RandomAccessContainer</code> whose <code>value_type</code> is <code>std::size_t</code>and of size 3. </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> and <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm_ref</td><td>the reference triangle_mesh. </td></tr>
    <tr><td class="paramname">points</td><td>the points of the soup. </td></tr>
    <tr><td class="paramname">triangles</td><td>the triangles of the soup. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__pmp__namedparameters.html">Named Parameters for Polygon Mesh Processing</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_vertex_point_map">vertex_point_map</a></td><td>the property map with the points associated to the vertices of <code>tm_ref</code>. If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> must be available in <code>TriangleMesh</code>  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_geom_traits">geom_traits</a></td><td>a geometric traits class instance. The traits class must provide the nested functor <code>Collinear_3</code> to check whether three points are collinear.  </td></tr>
</table>
</dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>The types of points in <code>PointRange</code>, <code>geom_traits</code> and <code>vertex_point_map</code> must be the same. </dd></dl>

</div>
</div>
<a id="ga21119757bf5835496ae1c9a6d4f5fa0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21119757bf5835496ae1c9a6d4f5fa0a">&#9670;&nbsp;</a></span>reverse_face_orientations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PolygonMesh , typename FaceRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::Polygon_mesh_processing::reverse_face_orientations </td>
          <td>(</td>
          <td class="paramtype">const FaceRange &amp;&#160;</td>
          <td class="paramname"><em>face_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PolygonMesh &amp;&#160;</td>
          <td class="paramname"><em>pmesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/orientation.h&gt;</code></p>
<p>reverses for each face in <code>face_range</code> the order of the vertices along the face boundary. The function does not perform any control and if the orientation change of the faces makes the polygon mesh invalid, the behavior is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolygonMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> and <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> </td></tr>
    <tr><td class="paramname">FaceRange</td><td>range of face descriptors, model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. Its iterator type is <code>InputIterator</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8a3439883e3e76651f96d15ba58b2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8a3439883e3e76651f96d15ba58b2bc">&#9670;&nbsp;</a></span>reverse_face_orientations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PolygonMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::Polygon_mesh_processing::reverse_face_orientations </td>
          <td>(</td>
          <td class="paramtype">PolygonMesh &amp;&#160;</td>
          <td class="paramname"><em>pmesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/orientation.h&gt;</code></p>
<p>reverses for each face the order of the vertices along the face boundary.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PolygonMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> and <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Polygon_mesh_processing_2orient_polygon_soup_example_8cpp-example.html#a6">Polygon_mesh_processing/orient_polygon_soup_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga133e58280959c152770525f27bb42b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga133e58280959c152770525f27bb42b91">&#9670;&nbsp;</a></span>volume_connected_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TriangleMesh , class VolumeFaceIndexMap , class NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CGAL::Polygon_mesh_processing::volume_connected_components </td>
          <td>(</td>
          <td class="paramtype">const TriangleMesh &amp;&#160;</td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VolumeFaceIndexMap&#160;</td>
          <td class="paramname"><em>volume_id_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/orientation.h&gt;</code></p>
<p>assigns to each face of <code>tm</code> an id corresponding to the volume connected component it contributes to.</p>
<p>Using the adjacency relation of two faces along an edge, a triangle mesh can be split into connected components (<em>surface components</em> in the following). A surface component without boundary separates the 3D space into an infinite and a finite volume. We say that the finite volume is <em>enclosed</em> by this surface component.</p>
<p>The volume connected components (<em>volume components</em> in the following) are defined as follows: Each surface component <code>S</code> that is outside any volume enclosed by another surface component defines the <em>outer boundary</em> of a volume component. Each surface component that is inside the volume enclosed by <code>S</code> defines a <em>hole</em> if it is included in no other volume enclosed by a surface component but <code>S</code>. Ignoring the identified volume component, the same procedure is recursively repeated for all surface components in each hole.</p>
<p>There are some special cases:</p><ul>
<li>a non-closed surface component is reported as a volume component ignoring any inclusion test</li>
<li>a self-intersecting surface component is reported as a volume component ignoring any inclusion test</li>
<li>a surface component intersecting another surface component is reported as a volume component, and so are all the surface components inside its enclosed volume</li>
<li>if <code>do_orientation_tests</code> is set to <code>true</code>, if the holes are not all equally oriented (all inward or all outward) or if the holes and the outer boundary are equally oriented, each surface component is reported as a volume component, and so are all the surface components inside the corresponding enclosed volumes</li>
<li>If <code>do_orientation_tests</code> is set to <code>true</code> and the surface components that are outside all enclosed volumes are inward oriented, they are then considered as holes of the unbounded volume (that has no outer boundary)</li>
</ul>
<p>A property map for <code>CGAL::vertex_point_t</code> must be either available as an internal property map of <code>tm</code> or provided as one of the <a class="el" href="group__pmp__namedparameters.html">Named Parameters</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> </td></tr>
    <tr><td class="paramname">VolumeFaceIndexMap</td><td>a model of <code>WritablePropertyMap</code> with <code>boost::graph_traits&lt;PolygonMesh&gt;::face_descriptor</code> as key type and <code>boost::graph_traits&lt;PolygonMesh&gt;::faces_size_type</code> as value type. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="el" href="group__pmp__namedparameters.html">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>the input triangle mesh </td></tr>
    <tr><td class="paramname">volume_id_map</td><td>the property map filled by this function with indices of volume components associated to the faces of <code>tm</code> </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__pmp__namedparameters.html">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>CGAL::is_closed(tm)</code></dd></dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_vertex_point_map">vertex_point_map</a></td><td>the property map with the points associated to the vertices of <code>tm</code>. If this parameter is omitted, an internal property map for <code>CGAL::vertex_point_t</code> must be available in <code>TriangleMesh</code>  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_face_index_map">face_index_map</a></td><td>a property map containing a unique id per face of <code>tm</code>, in the range <code>[0, num_faces(tm)[</code>  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_face_connected_component_map">face_connected_component_map</a></td><td>a property map filled by this function and that will contain for each face the id of its surface component in the range <code>[0, number of surface components - 1[</code>  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_volume_inclusions">volume_inclusions</a></td><td>a <code>reference_wrapper</code> (either from <code>boost</code> or the standard library) containing a reference to an object that must be a model of the <code>BackInsertionSequence</code> concept, with a value type being a model of <code>BackInsertionSequence</code> of <code>std::size_t</code>, both types having the functions <code>reserve()</code> and <code>push_back()</code>. The size of the container is exactly the number of surface components of <code>tm</code>. The container at position <code>k</code> contains the ids of all the surface components that are the first intersected by any ray with source on the surface component <code>k</code> and directed outside the volume enclosed by the surface component <code>k</code>. There is only one such id but when some surface components intersect.  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_do_orientation_tests">do_orientation_tests</a></td><td>if <code>true</code> (the default value), the orientation of the faces of each surface components will be taken into account for the definition of the volume. If <code>false</code>, the face orientation is ignored and the volumes are defined only by the nesting of surface components.  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_error_codes">error_codes</a></td><td>a <code>reference_wrapper</code> (either from <code>boost</code> or the standard library) containing a reference to a container that must be a model of the <code>BackInsertionSequence</code> concept, with a <code>value_type</code> being <a class="el" href="group__PMP__orientation__grp.html"><code>Volume_error_code</code> </a> The size of the container is exactly the number of volume components. The container indicates the status of a volume assigned to a set of faces. The description of the value type is given in the documentation of the enumeration type.  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_do_self_intersection_tests">do_self_intersection_tests</a></td><td>If <code>false</code> (the default value), it is assumed that <code>tm</code> does not contains any self-intersections. if <code>true</code>, the input might contain some self-intersections and a test is done prior to the volume decomposition.  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_connected_component_id_to_volume_id">connected_component_id_to_volume_id</a></td><td>a <code>reference_wrapper</code> (either from <code>boost</code> or the standard library) containing a reference to a container that must be a model of the <code>BackInsertionSequence</code> concept, with a value_type being <code>std::size_t</code>. The size of the container is exactly the number of connected components. For each connected component identified using its id <code>ccid</code>, the id of the volume it contributes to describe is the value at the position <code>ccid</code> in the container.  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_nesting_levels">nesting_levels</a></td><td>a <code>reference_wrapper</code> (either from <code>boost</code> or the standard library) containing a reference to a container that must be a model of the <code>BackInsertionSequence</code> concept, with a <code>value_type</code> being <code>std::size_t</code>. The size of the container is exactly the number of connected components. For each connected component identified using its id <code>ccid</code>, the container contains the number of connected components containing on its bounded side this component.  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_is_cc_outward_oriented">is_cc_outward_oriented</a></td><td>a <code>reference_wrapper</code> (either from <code>boost</code> or the standard library) containing a reference to a container that must be a model of the <code>BackInsertionSequence</code> concept, with a <code>value_type</code> being <code>bool</code>. The size of the container is exactly the number of connected components. For each connected component identified using its id <code>ccid</code>, the output of <code><a class="el" href="group__PMP__orientation__grp.html#ga53a77073bf9a4118ecf949b851e1f5d9">is_outward_oriented()</a></code> called on the triangle mesh corresponding to this connected component is the value at the position <code>ccid</code> in the container.  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__pmp__namedparameters.html#PMP_intersecting_volume_pairs_output_iterator">intersecting_volume_pairs_output_iterator</a></td><td><p class="starttd">Output iterator into which pairs of ids (id must be convertible to <code>std::size_t</code>) can be put. Each pair of connected components intersecting will be reported using their ids. If <code>do_self_intersection_tests</code> named parameter is set to <code>false</code>, nothing will be reported. </p>
<p class="endtd"></p>
</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of volume components defined by <code>tm</code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Polygon_mesh_processing_2volume_connected_components_8cpp-example.html#a2">Polygon_mesh_processing/volume_connected_components.cpp</a>.</dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</div>
</body>
</html>
